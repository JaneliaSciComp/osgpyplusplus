// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osgparticle.h"
#include "wrap_referenced.h"
#include "fluidfrictionoperator.pypp.hpp"

namespace bp = boost::python;

struct FluidFrictionOperator_wrapper : osgParticle::FluidFrictionOperator, bp::wrapper< osgParticle::FluidFrictionOperator > {

    FluidFrictionOperator_wrapper( )
    : osgParticle::FluidFrictionOperator( )
      , bp::wrapper< osgParticle::FluidFrictionOperator >(){
        // null constructor
    
    }

    virtual void beginOperate( ::osgParticle::Program * prg ) {
        if( bp::override func_beginOperate = this->get_override( "beginOperate" ) )
            func_beginOperate( boost::python::ptr(prg) );
        else{
            this->osgParticle::FluidFrictionOperator::beginOperate( boost::python::ptr(prg) );
        }
    }
    
    void default_beginOperate( ::osgParticle::Program * prg ) {
        osgParticle::FluidFrictionOperator::beginOperate( boost::python::ptr(prg) );
    }

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osgParticle::FluidFrictionOperator::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osgParticle::FluidFrictionOperator::className( );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone( boost::ref(copyop) );
        else{
            return this->osgParticle::FluidFrictionOperator::clone( boost::ref(copyop) );
        }
    }
    
    ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
        return osgParticle::FluidFrictionOperator::clone( boost::ref(copyop) );
    }

    virtual ::osg::Object * cloneType(  ) const  {
        if( bp::override func_cloneType = this->get_override( "cloneType" ) )
            return func_cloneType(  );
        else{
            return this->osgParticle::FluidFrictionOperator::cloneType(  );
        }
    }
    
    ::osg::Object * default_cloneType(  ) const  {
        return osgParticle::FluidFrictionOperator::cloneType( );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osgParticle::FluidFrictionOperator::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osgParticle::FluidFrictionOperator::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osgParticle::FluidFrictionOperator::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osgParticle::FluidFrictionOperator::libraryName( );
    }

    virtual void operate( ::osgParticle::Particle * P, double dt ) {
        if( bp::override func_operate = this->get_override( "operate" ) )
            func_operate( boost::python::ptr(P), dt );
        else{
            this->osgParticle::FluidFrictionOperator::operate( boost::python::ptr(P), dt );
        }
    }
    
    void default_operate( ::osgParticle::Particle * P, double dt ) {
        osgParticle::FluidFrictionOperator::operate( boost::python::ptr(P), dt );
    }

    virtual void computeDataVariance(  ) {
        if( bp::override func_computeDataVariance = this->get_override( "computeDataVariance" ) )
            func_computeDataVariance(  );
        else{
            this->osg::Object::computeDataVariance(  );
        }
    }
    
    void default_computeDataVariance(  ) {
        osg::Object::computeDataVariance( );
    }

    virtual void endOperate(  ) {
        if( bp::override func_endOperate = this->get_override( "endOperate" ) )
            func_endOperate(  );
        else{
            this->osgParticle::Operator::endOperate(  );
        }
    }
    
    void default_endOperate(  ) {
        osgParticle::Operator::endOperate( );
    }

    virtual ::osg::Referenced * getUserData(  ) {
        if( bp::override func_getUserData = this->get_override( "getUserData" ) )
            return func_getUserData(  );
        else{
            return this->osg::Object::getUserData(  );
        }
    }
    
    ::osg::Referenced * default_getUserData(  ) {
        return osg::Object::getUserData( );
    }

    virtual ::osg::Referenced const * getUserData(  ) const  {
        if( bp::override func_getUserData = this->get_override( "getUserData" ) )
            return func_getUserData(  );
        else{
            return this->osg::Object::getUserData(  );
        }
    }
    
    ::osg::Referenced const * default_getUserData(  ) const  {
        return osg::Object::getUserData( );
    }

    virtual void operateParticles( ::osgParticle::ParticleSystem * ps, double dt ) {
        if( bp::override func_operateParticles = this->get_override( "operateParticles" ) )
            func_operateParticles( boost::python::ptr(ps), dt );
        else{
            this->osgParticle::Operator::operateParticles( boost::python::ptr(ps), dt );
        }
    }
    
    void default_operateParticles( ::osgParticle::ParticleSystem * ps, double dt ) {
        osgParticle::Operator::operateParticles( boost::python::ptr(ps), dt );
    }

    virtual void resizeGLObjectBuffers( unsigned int arg0 ) {
        if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
            func_resizeGLObjectBuffers( arg0 );
        else{
            this->osg::Object::resizeGLObjectBuffers( arg0 );
        }
    }
    
    void default_resizeGLObjectBuffers( unsigned int arg0 ) {
        osg::Object::resizeGLObjectBuffers( arg0 );
    }

    virtual void setName( ::std::string const & name ) {
        if( bp::override func_setName = this->get_override( "setName" ) )
            func_setName( name );
        else{
            this->osg::Object::setName( name );
        }
    }
    
    void default_setName( ::std::string const & name ) {
        osg::Object::setName( name );
    }

    virtual void setThreadSafeRefUnref( bool threadSafe ) {
        if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
            func_setThreadSafeRefUnref( threadSafe );
        else{
            this->osg::Object::setThreadSafeRefUnref( threadSafe );
        }
    }
    
    void default_setThreadSafeRefUnref( bool threadSafe ) {
        osg::Object::setThreadSafeRefUnref( threadSafe );
    }

    virtual void setUserData( ::osg::Referenced * obj ) {
        if( bp::override func_setUserData = this->get_override( "setUserData" ) )
            func_setUserData( boost::python::ptr(obj) );
        else{
            this->osg::Object::setUserData( boost::python::ptr(obj) );
        }
    }
    
    void default_setUserData( ::osg::Referenced * obj ) {
        osg::Object::setUserData( boost::python::ptr(obj) );
    }

};

void register_FluidFrictionOperator_class(){

    bp::class_< FluidFrictionOperator_wrapper, bp::bases< osgParticle::Operator >, osg::ref_ptr< FluidFrictionOperator_wrapper >, boost::noncopyable >( "FluidFrictionOperator", "\n    An operator that simulates the friction of a fluid.\n        By using this operator you can let the particles move in a fluid of a given <I>density</I>\n        and <I>viscosity</I>. There are two functions to quickly setup the parameters for pure water\n        and air. You can decide whether to compute the forces using the particles physical\n        radius or another value, by calling the <CODE>setOverrideRadius()</CODE> method.\n", bp::no_init )    
        .def( bp::init< >("\n    An operator that simulates the friction of a fluid.\n        By using this operator you can let the particles move in a fluid of a given <I>density</I>\n        and <I>viscosity</I>. There are two functions to quickly setup the parameters for pure water\n        and air. You can decide whether to compute the forces using the particles physical\n        radius or another value, by calling the <CODE>setOverrideRadius()</CODE> method.\n") )    
        .def( 
            "beginOperate"
            , (void ( ::osgParticle::FluidFrictionOperator::* )( ::osgParticle::Program * ))(&::osgParticle::FluidFrictionOperator::beginOperate)
            , (void ( FluidFrictionOperator_wrapper::* )( ::osgParticle::Program * ))(&FluidFrictionOperator_wrapper::default_beginOperate)
            , ( bp::arg("prg") ) )    
        .def( 
            "className"
            , (char const * ( ::osgParticle::FluidFrictionOperator::* )(  )const)(&::osgParticle::FluidFrictionOperator::className)
            , (char const * ( FluidFrictionOperator_wrapper::* )(  )const)(&FluidFrictionOperator_wrapper::default_className) )    
        .def( 
            "clone"
            , (::osg::Object * ( ::osgParticle::FluidFrictionOperator::* )( ::osg::CopyOp const & )const)(&::osgParticle::FluidFrictionOperator::clone)
            , (::osg::Object * ( FluidFrictionOperator_wrapper::* )( ::osg::CopyOp const & )const)(&FluidFrictionOperator_wrapper::default_clone)
            , ( bp::arg("copyop") )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "cloneType"
            , (::osg::Object * ( ::osgParticle::FluidFrictionOperator::* )(  )const)(&::osgParticle::FluidFrictionOperator::cloneType)
            , (::osg::Object * ( FluidFrictionOperator_wrapper::* )(  )const)(&FluidFrictionOperator_wrapper::default_cloneType)
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "getFluidDensity"
            , (float ( ::osgParticle::FluidFrictionOperator::* )(  )const)( &::osgParticle::FluidFrictionOperator::getFluidDensity ) )    
        .def( 
            "getFluidViscosity"
            , (float ( ::osgParticle::FluidFrictionOperator::* )(  )const)( &::osgParticle::FluidFrictionOperator::getFluidViscosity ) )    
        .def( 
            "getOverrideRadius"
            , (float ( ::osgParticle::FluidFrictionOperator::* )(  )const)( &::osgParticle::FluidFrictionOperator::getOverrideRadius ) )    
        .def( 
            "getWind"
            , (::osg::Vec3 const & ( ::osgParticle::FluidFrictionOperator::* )(  )const)( &::osgParticle::FluidFrictionOperator::getWind )
            , bp::return_internal_reference< >()
            , " Get the wind vector." )    
        .def( 
            "isSameKindAs"
            , (bool ( ::osgParticle::FluidFrictionOperator::* )( ::osg::Object const * )const)(&::osgParticle::FluidFrictionOperator::isSameKindAs)
            , (bool ( FluidFrictionOperator_wrapper::* )( ::osg::Object const * )const)(&FluidFrictionOperator_wrapper::default_isSameKindAs)
            , ( bp::arg("obj") ) )    
        .def( 
            "libraryName"
            , (char const * ( ::osgParticle::FluidFrictionOperator::* )(  )const)(&::osgParticle::FluidFrictionOperator::libraryName)
            , (char const * ( FluidFrictionOperator_wrapper::* )(  )const)(&FluidFrictionOperator_wrapper::default_libraryName) )    
        .def( 
            "operate"
            , (void ( ::osgParticle::FluidFrictionOperator::* )( ::osgParticle::Particle *,double ))(&::osgParticle::FluidFrictionOperator::operate)
            , (void ( FluidFrictionOperator_wrapper::* )( ::osgParticle::Particle *,double ))(&FluidFrictionOperator_wrapper::default_operate)
            , ( bp::arg("P"), bp::arg("dt") ) )    
        .def( 
            "setFluidDensity"
            , (void ( ::osgParticle::FluidFrictionOperator::* )( float ))( &::osgParticle::FluidFrictionOperator::setFluidDensity )
            , ( bp::arg("d") ) )    
        .def( 
            "setFluidToAir"
            , (void ( ::osgParticle::FluidFrictionOperator::* )(  ))( &::osgParticle::FluidFrictionOperator::setFluidToAir ) )    
        .def( 
            "setFluidToWater"
            , (void ( ::osgParticle::FluidFrictionOperator::* )(  ))( &::osgParticle::FluidFrictionOperator::setFluidToWater ) )    
        .def( 
            "setFluidViscosity"
            , (void ( ::osgParticle::FluidFrictionOperator::* )( float ))( &::osgParticle::FluidFrictionOperator::setFluidViscosity )
            , ( bp::arg("v") ) )    
        .def( 
            "setOverrideRadius"
            , (void ( ::osgParticle::FluidFrictionOperator::* )( float ))( &::osgParticle::FluidFrictionOperator::setOverrideRadius )
            , ( bp::arg("r") ) )    
        .def( 
            "setWind"
            , (void ( ::osgParticle::FluidFrictionOperator::* )( ::osg::Vec3 const & ))( &::osgParticle::FluidFrictionOperator::setWind )
            , ( bp::arg("wind") )
            , " Set the wind vector." )    
        .def( 
            "endOperate"
            , (void ( ::osgParticle::Operator::* )(  ))(&::osgParticle::Operator::endOperate)
            , (void ( FluidFrictionOperator_wrapper::* )(  ))(&FluidFrictionOperator_wrapper::default_endOperate) )    
        .def( 
            "operateParticles"
            , (void ( ::osgParticle::Operator::* )( ::osgParticle::ParticleSystem *,double ))(&::osgParticle::Operator::operateParticles)
            , (void ( FluidFrictionOperator_wrapper::* )( ::osgParticle::ParticleSystem *,double ))(&FluidFrictionOperator_wrapper::default_operateParticles)
            , ( bp::arg("ps"), bp::arg("dt") ) );

}
