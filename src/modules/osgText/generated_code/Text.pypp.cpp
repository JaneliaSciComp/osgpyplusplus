// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__array_1.pypp.hpp"
#include "wrap_osgtext.h"
#include "wrap_referenced.h"
#include "text.pypp.hpp"

namespace bp = boost::python;

struct Text_wrapper : osgText::Text, bp::wrapper< osgText::Text > {

    struct GlyphQuads_wrapper : osgText::Text::GlyphQuads, bp::wrapper< osgText::Text::GlyphQuads > {
    
        GlyphQuads_wrapper(osgText::Text::GlyphQuads const & arg )
        : osgText::Text::GlyphQuads( arg )
          , bp::wrapper< osgText::Text::GlyphQuads >(){
            // copy constructor
            
        }
    
        GlyphQuads_wrapper()
        : osgText::Text::GlyphQuads()
          , bp::wrapper< osgText::Text::GlyphQuads >(){
            // null constructor
            
        }
    
        static pyplusplus::containers::static_sized::array_1_t< ::osg::buffered_object<std::vector<osg::Vec3f, std::allocator<osg::Vec3f> > >, 8>
        pyplusplus__transformedBackdropCoords_wrapper( ::osgText::Text::GlyphQuads & inst ){
            return pyplusplus::containers::static_sized::array_1_t< ::osg::buffered_object<std::vector<osg::Vec3f, std::allocator<osg::Vec3f> > >, 8>( inst._transformedBackdropCoords );
        }
    
    };

    Text_wrapper( )
    : osgText::Text( )
      , bp::wrapper< osgText::Text >(){
        // null constructor
    
    }

    virtual void accept( ::osg::Drawable::ConstAttributeFunctor & af ) const  {
        if( bp::override func_accept = this->get_override( "accept" ) )
            func_accept( boost::ref(af) );
        else{
            this->osgText::Text::accept( boost::ref(af) );
        }
    }
    
    void default_accept( ::osg::Drawable::ConstAttributeFunctor & af ) const  {
        osgText::Text::accept( boost::ref(af) );
    }

    virtual void accept( ::osg::PrimitiveFunctor & pf ) const  {
        if( bp::override func_accept = this->get_override( "accept" ) )
            func_accept( boost::ref(pf) );
        else{
            this->osgText::Text::accept( boost::ref(pf) );
        }
    }
    
    void default_accept( ::osg::PrimitiveFunctor & pf ) const  {
        osgText::Text::accept( boost::ref(pf) );
    }

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osgText::Text::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osgText::Text::className( );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone( boost::ref(copyop) );
        else{
            return this->osgText::Text::clone( boost::ref(copyop) );
        }
    }
    
    ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
        return osgText::Text::clone( boost::ref(copyop) );
    }

    virtual ::osg::Object * cloneType(  ) const  {
        if( bp::override func_cloneType = this->get_override( "cloneType" ) )
            return func_cloneType(  );
        else{
            return this->osgText::Text::cloneType(  );
        }
    }
    
    ::osg::Object * default_cloneType(  ) const  {
        return osgText::Text::cloneType( );
    }

    virtual void drawImplementation( ::osg::RenderInfo & renderInfo ) const  {
        if( bp::override func_drawImplementation = this->get_override( "drawImplementation" ) )
            func_drawImplementation( boost::ref(renderInfo) );
        else{
            this->osgText::Text::drawImplementation( boost::ref(renderInfo) );
        }
    }
    
    void default_drawImplementation( ::osg::RenderInfo & renderInfo ) const  {
        osgText::Text::drawImplementation( boost::ref(renderInfo) );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osgText::Text::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osgText::Text::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osgText::Text::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osgText::Text::libraryName( );
    }

    virtual void releaseGLObjects( ::osg::State * state=0 ) const  {
        if( bp::override func_releaseGLObjects = this->get_override( "releaseGLObjects" ) )
            func_releaseGLObjects( boost::python::ptr(state) );
        else{
            this->osgText::Text::releaseGLObjects( boost::python::ptr(state) );
        }
    }
    
    void default_releaseGLObjects( ::osg::State * state=0 ) const  {
        osgText::Text::releaseGLObjects( boost::python::ptr(state) );
    }

    virtual void resizeGLObjectBuffers( unsigned int maxSize ) {
        if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
            func_resizeGLObjectBuffers( maxSize );
        else{
            this->osgText::Text::resizeGLObjectBuffers( maxSize );
        }
    }
    
    void default_resizeGLObjectBuffers( unsigned int maxSize ) {
        osgText::Text::resizeGLObjectBuffers( maxSize );
    }

    virtual void setFont( ::osgText::Font * font=0 ) {
        if( bp::override func_setFont = this->get_override( "setFont" ) )
            func_setFont( boost::python::ptr(font) );
        else{
            this->osgText::Text::setFont( boost::python::ptr(font) );
        }
    }
    
    void default_setFont( ::osgText::Font * font=0 ) {
        osgText::Text::setFont( boost::python::ptr(font) );
    }

    virtual void setFont( ::osg::ref_ptr< osgText::Font > font ) {
        if( bp::override func_setFont = this->get_override( "setFont" ) )
            func_setFont( font );
        else{
            this->osgText::Text::setFont( font );
        }
    }
    
    void default_setFont( ::osg::ref_ptr< osgText::Font > font ) {
        osgText::Text::setFont( font );
    }

    virtual void setFont( ::std::string const & fontfile ) {
        if( bp::override func_setFont = this->get_override( "setFont" ) )
            func_setFont( fontfile );
        else{
            this->osgText::Text::setFont( fontfile );
        }
    }
    
    void default_setFont( ::std::string const & fontfile ) {
        osgText::Text::setFont( fontfile );
    }

    virtual void setThreadSafeRefUnref( bool threadSafe ) {
        if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
            func_setThreadSafeRefUnref( threadSafe );
        else{
            this->osgText::Text::setThreadSafeRefUnref( threadSafe );
        }
    }
    
    void default_setThreadSafeRefUnref( bool threadSafe ) {
        osgText::Text::setThreadSafeRefUnref( threadSafe );
    }

    virtual bool supports( ::osg::Drawable::AttributeFunctor const & arg0 ) const  {
        if( bp::override func_supports = this->get_override( "supports" ) )
            return func_supports( boost::ref(arg0) );
        else{
            return this->osgText::Text::supports( boost::ref(arg0) );
        }
    }
    
    bool default_supports( ::osg::Drawable::AttributeFunctor const & arg0 ) const  {
        return osgText::Text::supports( boost::ref(arg0) );
    }

    virtual bool supports( ::osg::Drawable::ConstAttributeFunctor const & arg0 ) const  {
        if( bp::override func_supports = this->get_override( "supports" ) )
            return func_supports( boost::ref(arg0) );
        else{
            return this->osgText::Text::supports( boost::ref(arg0) );
        }
    }
    
    bool default_supports( ::osg::Drawable::ConstAttributeFunctor const & arg0 ) const  {
        return osgText::Text::supports( boost::ref(arg0) );
    }

    virtual bool supports( ::osg::PrimitiveFunctor const & arg0 ) const  {
        if( bp::override func_supports = this->get_override( "supports" ) )
            return func_supports( boost::ref(arg0) );
        else{
            return this->osgText::Text::supports( boost::ref(arg0) );
        }
    }
    
    bool default_supports( ::osg::PrimitiveFunctor const & arg0 ) const  {
        return osgText::Text::supports( boost::ref(arg0) );
    }

    virtual void accept( ::osg::Drawable::AttributeFunctor & arg0 ) {
        if( bp::override func_accept = this->get_override( "accept" ) )
            func_accept( boost::ref(arg0) );
        else{
            this->osg::Drawable::accept( boost::ref(arg0) );
        }
    }
    
    void default_accept( ::osg::Drawable::AttributeFunctor & arg0 ) {
        osg::Drawable::accept( boost::ref(arg0) );
    }

    virtual void accept( ::osg::PrimitiveIndexFunctor & arg0 ) const  {
        if( bp::override func_accept = this->get_override( "accept" ) )
            func_accept( boost::ref(arg0) );
        else{
            this->osg::Drawable::accept( boost::ref(arg0) );
        }
    }
    
    void default_accept( ::osg::PrimitiveIndexFunctor & arg0 ) const  {
        osg::Drawable::accept( boost::ref(arg0) );
    }

    virtual ::osg::Geometry * asGeometry(  ) {
        if( bp::override func_asGeometry = this->get_override( "asGeometry" ) )
            return func_asGeometry(  );
        else{
            return this->osg::Drawable::asGeometry(  );
        }
    }
    
    ::osg::Geometry * default_asGeometry(  ) {
        return osg::Drawable::asGeometry( );
    }

    virtual ::osg::Geometry const * asGeometry(  ) const  {
        if( bp::override func_asGeometry = this->get_override( "asGeometry" ) )
            return func_asGeometry(  );
        else{
            return this->osg::Drawable::asGeometry(  );
        }
    }
    
    ::osg::Geometry const * default_asGeometry(  ) const  {
        return osg::Drawable::asGeometry( );
    }

    virtual void compileGLObjects( ::osg::RenderInfo & renderInfo ) const  {
        if( bp::override func_compileGLObjects = this->get_override( "compileGLObjects" ) )
            func_compileGLObjects( boost::ref(renderInfo) );
        else{
            this->osg::Drawable::compileGLObjects( boost::ref(renderInfo) );
        }
    }
    
    void default_compileGLObjects( ::osg::RenderInfo & renderInfo ) const  {
        osg::Drawable::compileGLObjects( boost::ref(renderInfo) );
    }

    virtual ::osg::BoundingBox computeBound(  ) const  {
        if( bp::override func_computeBound = this->get_override( "computeBound" ) )
            return func_computeBound(  );
        else{
            return this->osgText::TextBase::computeBound(  );
        }
    }
    
    ::osg::BoundingBox default_computeBound(  ) const  {
        return osgText::TextBase::computeBound( );
    }

    virtual void computeDataVariance(  ) {
        if( bp::override func_computeDataVariance = this->get_override( "computeDataVariance" ) )
            func_computeDataVariance(  );
        else{
            this->osg::Drawable::computeDataVariance(  );
        }
    }
    
    void default_computeDataVariance(  ) {
        osg::Drawable::computeDataVariance( );
    }

    virtual void dirtyDisplayList(  ) {
        if( bp::override func_dirtyDisplayList = this->get_override( "dirtyDisplayList" ) )
            func_dirtyDisplayList(  );
        else{
            this->osg::Drawable::dirtyDisplayList(  );
        }
    }
    
    void default_dirtyDisplayList(  ) {
        osg::Drawable::dirtyDisplayList( );
    }

    virtual unsigned int getGLObjectSizeHint(  ) const  {
        if( bp::override func_getGLObjectSizeHint = this->get_override( "getGLObjectSizeHint" ) )
            return func_getGLObjectSizeHint(  );
        else{
            return this->osg::Drawable::getGLObjectSizeHint(  );
        }
    }
    
    unsigned int default_getGLObjectSizeHint(  ) const  {
        return osg::Drawable::getGLObjectSizeHint( );
    }

    virtual ::osg::Referenced * getUserData(  ) {
        if( bp::override func_getUserData = this->get_override( "getUserData" ) )
            return func_getUserData(  );
        else{
            return this->osg::Object::getUserData(  );
        }
    }
    
    ::osg::Referenced * default_getUserData(  ) {
        return osg::Object::getUserData( );
    }

    virtual ::osg::Referenced const * getUserData(  ) const  {
        if( bp::override func_getUserData = this->get_override( "getUserData" ) )
            return func_getUserData(  );
        else{
            return this->osg::Object::getUserData(  );
        }
    }
    
    ::osg::Referenced const * default_getUserData(  ) const  {
        return osg::Object::getUserData( );
    }

    virtual void setCullCallback( ::osg::Drawable::CullCallback * cc ) {
        if( bp::override func_setCullCallback = this->get_override( "setCullCallback" ) )
            func_setCullCallback( boost::python::ptr(cc) );
        else{
            this->osg::Drawable::setCullCallback( boost::python::ptr(cc) );
        }
    }
    
    void default_setCullCallback( ::osg::Drawable::CullCallback * cc ) {
        osg::Drawable::setCullCallback( boost::python::ptr(cc) );
    }

    virtual void setDrawCallback( ::osg::Drawable::DrawCallback * dc ) {
        if( bp::override func_setDrawCallback = this->get_override( "setDrawCallback" ) )
            func_setDrawCallback( boost::python::ptr(dc) );
        else{
            this->osg::Drawable::setDrawCallback( boost::python::ptr(dc) );
        }
    }
    
    void default_setDrawCallback( ::osg::Drawable::DrawCallback * dc ) {
        osg::Drawable::setDrawCallback( boost::python::ptr(dc) );
    }

    virtual void setEventCallback( ::osg::Drawable::EventCallback * ac ) {
        if( bp::override func_setEventCallback = this->get_override( "setEventCallback" ) )
            func_setEventCallback( boost::python::ptr(ac) );
        else{
            this->osg::Drawable::setEventCallback( boost::python::ptr(ac) );
        }
    }
    
    void default_setEventCallback( ::osg::Drawable::EventCallback * ac ) {
        osg::Drawable::setEventCallback( boost::python::ptr(ac) );
    }

    virtual void setName( ::std::string const & name ) {
        if( bp::override func_setName = this->get_override( "setName" ) )
            func_setName( name );
        else{
            this->osg::Object::setName( name );
        }
    }
    
    void default_setName( ::std::string const & name ) {
        osg::Object::setName( name );
    }

    virtual void setUpdateCallback( ::osg::Drawable::UpdateCallback * ac ) {
        if( bp::override func_setUpdateCallback = this->get_override( "setUpdateCallback" ) )
            func_setUpdateCallback( boost::python::ptr(ac) );
        else{
            this->osg::Drawable::setUpdateCallback( boost::python::ptr(ac) );
        }
    }
    
    void default_setUpdateCallback( ::osg::Drawable::UpdateCallback * ac ) {
        osg::Drawable::setUpdateCallback( boost::python::ptr(ac) );
    }

    virtual void setUseVertexBufferObjects( bool flag ) {
        if( bp::override func_setUseVertexBufferObjects = this->get_override( "setUseVertexBufferObjects" ) )
            func_setUseVertexBufferObjects( flag );
        else{
            this->osg::Drawable::setUseVertexBufferObjects( flag );
        }
    }
    
    void default_setUseVertexBufferObjects( bool flag ) {
        osg::Drawable::setUseVertexBufferObjects( flag );
    }

    virtual void setUserData( ::osg::Referenced * obj ) {
        if( bp::override func_setUserData = this->get_override( "setUserData" ) )
            func_setUserData( boost::python::ptr(obj) );
        else{
            this->osg::Object::setUserData( boost::python::ptr(obj) );
        }
    }
    
    void default_setUserData( ::osg::Referenced * obj ) {
        osg::Object::setUserData( boost::python::ptr(obj) );
    }

    virtual bool supports( ::osg::PrimitiveIndexFunctor const & arg0 ) const  {
        if( bp::override func_supports = this->get_override( "supports" ) )
            return func_supports( boost::ref(arg0) );
        else{
            return this->osg::Drawable::supports( boost::ref(arg0) );
        }
    }
    
    bool default_supports( ::osg::PrimitiveIndexFunctor const & arg0 ) const  {
        return osg::Drawable::supports( boost::ref(arg0) );
    }

};

void register_Text_class(){

    { //::osgText::Text
        typedef bp::class_< Text_wrapper, bp::bases< osgText::TextBase >, osg::ref_ptr< Text_wrapper >, boost::noncopyable > Text_exposer_t;
        Text_exposer_t Text_exposer = Text_exposer_t( "Text", bp::no_init );
        bp::scope Text_scope( Text_exposer );
        bp::enum_< osgText::Text::BackdropImplementation>("BackdropImplementation")
            .value("POLYGON_OFFSET", osgText::Text::POLYGON_OFFSET)
            .value("NO_DEPTH_BUFFER", osgText::Text::NO_DEPTH_BUFFER)
            .value("DEPTH_RANGE", osgText::Text::DEPTH_RANGE)
            .value("STENCIL_BUFFER", osgText::Text::STENCIL_BUFFER)
            .value("DELAYED_DEPTH_WRITES", osgText::Text::DELAYED_DEPTH_WRITES)
            .export_values()
            ;
        bp::enum_< osgText::Text::BackdropType>("BackdropType")
            .value("DROP_SHADOW_BOTTOM_RIGHT", osgText::Text::DROP_SHADOW_BOTTOM_RIGHT)
            .value("DROP_SHADOW_CENTER_RIGHT", osgText::Text::DROP_SHADOW_CENTER_RIGHT)
            .value("DROP_SHADOW_TOP_RIGHT", osgText::Text::DROP_SHADOW_TOP_RIGHT)
            .value("DROP_SHADOW_BOTTOM_CENTER", osgText::Text::DROP_SHADOW_BOTTOM_CENTER)
            .value("DROP_SHADOW_TOP_CENTER", osgText::Text::DROP_SHADOW_TOP_CENTER)
            .value("DROP_SHADOW_BOTTOM_LEFT", osgText::Text::DROP_SHADOW_BOTTOM_LEFT)
            .value("DROP_SHADOW_CENTER_LEFT", osgText::Text::DROP_SHADOW_CENTER_LEFT)
            .value("DROP_SHADOW_TOP_LEFT", osgText::Text::DROP_SHADOW_TOP_LEFT)
            .value("OUTLINE", osgText::Text::OUTLINE)
            .value("NONE", osgText::Text::NONE)
            .export_values()
            ;
        bp::enum_< osgText::Text::ColorGradientMode>("ColorGradientMode")
            .value("SOLID", osgText::Text::SOLID)
            .value("PER_CHARACTER", osgText::Text::PER_CHARACTER)
            .value("OVERALL", osgText::Text::OVERALL)
            .export_values()
            ;
        { //::osgText::Text::GlyphQuads
            typedef bp::class_< Text_wrapper::GlyphQuads_wrapper > GlyphQuads_exposer_t;
            GlyphQuads_exposer_t GlyphQuads_exposer = GlyphQuads_exposer_t( "GlyphQuads" );
            bp::scope GlyphQuads_scope( GlyphQuads_exposer );
            { //::osgText::Text::GlyphQuads::getCoords
            
                typedef ::std::vector< osg::Vec2f > & ( ::osgText::Text::GlyphQuads::*getCoords_function_type)(  ) ;
                
                GlyphQuads_exposer.def( 
                    "getCoords"
                    , getCoords_function_type( &::osgText::Text::GlyphQuads::getCoords )
                    , bp::return_internal_reference< >() );
            
            }
            { //::osgText::Text::GlyphQuads::getCoords
            
                typedef ::std::vector< osg::Vec2f > const & ( ::osgText::Text::GlyphQuads::*getCoords_function_type)(  ) const;
                
                GlyphQuads_exposer.def( 
                    "getCoords"
                    , getCoords_function_type( &::osgText::Text::GlyphQuads::getCoords )
                    , bp::return_internal_reference< >() );
            
            }
            { //::osgText::Text::GlyphQuads::getGlyphs
            
                typedef ::std::vector< osgText::Glyph* > ( ::osgText::Text::GlyphQuads::*getGlyphs_function_type)(  ) ;
                
                GlyphQuads_exposer.def( 
                    "getGlyphs"
                    , getGlyphs_function_type( &::osgText::Text::GlyphQuads::getGlyphs ) );
            
            }
            { //::osgText::Text::GlyphQuads::getGlyphs
            
                typedef ::std::vector< osgText::Glyph* > const ( ::osgText::Text::GlyphQuads::*getGlyphs_function_type)(  ) const;
                
                GlyphQuads_exposer.def( 
                    "getGlyphs"
                    , getGlyphs_function_type( &::osgText::Text::GlyphQuads::getGlyphs ) );
            
            }
            { //::osgText::Text::GlyphQuads::getLineNumbers
            
                typedef ::std::vector< unsigned int > & ( ::osgText::Text::GlyphQuads::*getLineNumbers_function_type)(  ) ;
                
                GlyphQuads_exposer.def( 
                    "getLineNumbers"
                    , getLineNumbers_function_type( &::osgText::Text::GlyphQuads::getLineNumbers )
                    , bp::return_internal_reference< >() );
            
            }
            { //::osgText::Text::GlyphQuads::getLineNumbers
            
                typedef ::std::vector< unsigned int > const & ( ::osgText::Text::GlyphQuads::*getLineNumbers_function_type)(  ) const;
                
                GlyphQuads_exposer.def( 
                    "getLineNumbers"
                    , getLineNumbers_function_type( &::osgText::Text::GlyphQuads::getLineNumbers )
                    , bp::return_internal_reference< >() );
            
            }
            { //::osgText::Text::GlyphQuads::getTexCoords
            
                typedef ::std::vector< osg::Vec2f > & ( ::osgText::Text::GlyphQuads::*getTexCoords_function_type)(  ) ;
                
                GlyphQuads_exposer.def( 
                    "getTexCoords"
                    , getTexCoords_function_type( &::osgText::Text::GlyphQuads::getTexCoords )
                    , bp::return_internal_reference< >() );
            
            }
            { //::osgText::Text::GlyphQuads::getTexCoords
            
                typedef ::std::vector< osg::Vec2f > const & ( ::osgText::Text::GlyphQuads::*getTexCoords_function_type)(  ) const;
                
                GlyphQuads_exposer.def( 
                    "getTexCoords"
                    , getTexCoords_function_type( &::osgText::Text::GlyphQuads::getTexCoords )
                    , bp::return_internal_reference< >() );
            
            }
            { //::osgText::Text::GlyphQuads::getTransformedCoords
            
                typedef ::std::vector< osg::Vec3f > & ( ::osgText::Text::GlyphQuads::*getTransformedCoords_function_type)( unsigned int ) ;
                
                GlyphQuads_exposer.def( 
                    "getTransformedCoords"
                    , getTransformedCoords_function_type( &::osgText::Text::GlyphQuads::getTransformedCoords )
                    , ( bp::arg("contexID") )
                    , bp::return_internal_reference< >() );
            
            }
            { //::osgText::Text::GlyphQuads::getTransformedCoords
            
                typedef ::std::vector< osg::Vec3f > const & ( ::osgText::Text::GlyphQuads::*getTransformedCoords_function_type)( unsigned int ) const;
                
                GlyphQuads_exposer.def( 
                    "getTransformedCoords"
                    , getTransformedCoords_function_type( &::osgText::Text::GlyphQuads::getTransformedCoords )
                    , ( bp::arg("contexID") )
                    , bp::return_internal_reference< >() );
            
            }
            GlyphQuads_exposer.def_readwrite( "_colorCoords", &osgText::Text::GlyphQuads::_colorCoords );
            GlyphQuads_exposer.def_readwrite( "_coords", &osgText::Text::GlyphQuads::_coords );
            GlyphQuads_exposer.def_readwrite( "_glyphs", &osgText::Text::GlyphQuads::_glyphs );
            GlyphQuads_exposer.def_readwrite( "_lineNumbers", &osgText::Text::GlyphQuads::_lineNumbers );
            GlyphQuads_exposer.def_readwrite( "_texcoords", &osgText::Text::GlyphQuads::_texcoords );
            pyplusplus::containers::static_sized::register_array_1< ::osg::buffered_object<std::vector<osg::Vec3f, std::allocator<osg::Vec3f> > >, 8, bp::return_internal_reference< > >( "__array_1__scope_osg_scope_buffered_object_less_std_scope_vector_less_osg_scope_Vec3f_comma__std_scope_allocator_less_osg_scope_Vec3f_greater___greater___greater__8" );
            { //osgText::Text::GlyphQuads::_transformedBackdropCoords [variable], type=osg::buffered_object<std::vector<osg::Vec3f, std::allocator<osg::Vec3f> > >[8]
            
                typedef pyplusplus::containers::static_sized::array_1_t< ::osg::buffered_object<std::vector<osg::Vec3f, std::allocator<osg::Vec3f> > >, 8> ( *array_wrapper_creator )( ::osgText::Text::GlyphQuads & );
                
                GlyphQuads_exposer.add_property( "_transformedBackdropCoords"
                    , bp::make_function( array_wrapper_creator(&Text_wrapper::GlyphQuads_wrapper::pyplusplus__transformedBackdropCoords_wrapper)
                                        , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
            }
            GlyphQuads_exposer.def_readwrite( "_transformedCoords", &osgText::Text::GlyphQuads::_transformedCoords );
        }
        Text_exposer.def( bp::init< >() );
        { //::osgText::Text::accept
        
            typedef void ( ::osgText::Text::*accept_function_type)( ::osg::Drawable::ConstAttributeFunctor & ) const;
            typedef void ( Text_wrapper::*default_accept_function_type)( ::osg::Drawable::ConstAttributeFunctor & ) const;
            
            Text_exposer.def( 
                "accept"
                , accept_function_type(&::osgText::Text::accept)
                , default_accept_function_type(&Text_wrapper::default_accept)
                , ( bp::arg("af") ) );
        
        }
        { //::osgText::Text::accept
        
            typedef void ( ::osgText::Text::*accept_function_type)( ::osg::PrimitiveFunctor & ) const;
            typedef void ( Text_wrapper::*default_accept_function_type)( ::osg::PrimitiveFunctor & ) const;
            
            Text_exposer.def( 
                "accept"
                , accept_function_type(&::osgText::Text::accept)
                , default_accept_function_type(&Text_wrapper::default_accept)
                , ( bp::arg("pf") ) );
        
        }
        { //::osgText::Text::className
        
            typedef char const * ( ::osgText::Text::*className_function_type)(  ) const;
            typedef char const * ( Text_wrapper::*default_className_function_type)(  ) const;
            
            Text_exposer.def( 
                "className"
                , className_function_type(&::osgText::Text::className)
                , default_className_function_type(&Text_wrapper::default_className) );
        
        }
        { //::osgText::Text::clone
        
            typedef ::osg::Object * ( ::osgText::Text::*clone_function_type)( ::osg::CopyOp const & ) const;
            typedef ::osg::Object * ( Text_wrapper::*default_clone_function_type)( ::osg::CopyOp const & ) const;
            
            Text_exposer.def( 
                "clone"
                , clone_function_type(&::osgText::Text::clone)
                , default_clone_function_type(&Text_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osgText::Text::cloneType
        
            typedef ::osg::Object * ( ::osgText::Text::*cloneType_function_type)(  ) const;
            typedef ::osg::Object * ( Text_wrapper::*default_cloneType_function_type)(  ) const;
            
            Text_exposer.def( 
                "cloneType"
                , cloneType_function_type(&::osgText::Text::cloneType)
                , default_cloneType_function_type(&Text_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osgText::Text::drawImplementation
        
            typedef void ( ::osgText::Text::*drawImplementation_function_type)( ::osg::RenderInfo & ) const;
            typedef void ( Text_wrapper::*default_drawImplementation_function_type)( ::osg::RenderInfo & ) const;
            
            Text_exposer.def( 
                "drawImplementation"
                , drawImplementation_function_type(&::osgText::Text::drawImplementation)
                , default_drawImplementation_function_type(&Text_wrapper::default_drawImplementation)
                , ( bp::arg("renderInfo") ) );
        
        }
        { //::osgText::Text::getBackdropColor
        
            typedef ::osg::Vec4 const & ( ::osgText::Text::*getBackdropColor_function_type)(  ) const;
            
            Text_exposer.def( 
                "getBackdropColor"
                , getBackdropColor_function_type( &::osgText::Text::getBackdropColor )
                , bp::return_internal_reference< >() );
        
        }
        { //::osgText::Text::getBackdropHorizontalOffset
        
            typedef float ( ::osgText::Text::*getBackdropHorizontalOffset_function_type)(  ) const;
            
            Text_exposer.def( 
                "getBackdropHorizontalOffset"
                , getBackdropHorizontalOffset_function_type( &::osgText::Text::getBackdropHorizontalOffset ) );
        
        }
        { //::osgText::Text::getBackdropImplementation
        
            typedef ::osgText::Text::BackdropImplementation ( ::osgText::Text::*getBackdropImplementation_function_type)(  ) const;
            
            Text_exposer.def( 
                "getBackdropImplementation"
                , getBackdropImplementation_function_type( &::osgText::Text::getBackdropImplementation ) );
        
        }
        { //::osgText::Text::getBackdropType
        
            typedef ::osgText::Text::BackdropType ( ::osgText::Text::*getBackdropType_function_type)(  ) const;
            
            Text_exposer.def( 
                "getBackdropType"
                , getBackdropType_function_type( &::osgText::Text::getBackdropType ) );
        
        }
        { //::osgText::Text::getBackdropVerticalOffset
        
            typedef float ( ::osgText::Text::*getBackdropVerticalOffset_function_type)(  ) const;
            
            Text_exposer.def( 
                "getBackdropVerticalOffset"
                , getBackdropVerticalOffset_function_type( &::osgText::Text::getBackdropVerticalOffset ) );
        
        }
        { //::osgText::Text::getColorGradientBottomLeft
        
            typedef ::osg::Vec4 const & ( ::osgText::Text::*getColorGradientBottomLeft_function_type)(  ) const;
            
            Text_exposer.def( 
                "getColorGradientBottomLeft"
                , getColorGradientBottomLeft_function_type( &::osgText::Text::getColorGradientBottomLeft )
                , bp::return_internal_reference< >() );
        
        }
        { //::osgText::Text::getColorGradientBottomRight
        
            typedef ::osg::Vec4 const & ( ::osgText::Text::*getColorGradientBottomRight_function_type)(  ) const;
            
            Text_exposer.def( 
                "getColorGradientBottomRight"
                , getColorGradientBottomRight_function_type( &::osgText::Text::getColorGradientBottomRight )
                , bp::return_internal_reference< >() );
        
        }
        { //::osgText::Text::getColorGradientMode
        
            typedef ::osgText::Text::ColorGradientMode ( ::osgText::Text::*getColorGradientMode_function_type)(  ) const;
            
            Text_exposer.def( 
                "getColorGradientMode"
                , getColorGradientMode_function_type( &::osgText::Text::getColorGradientMode ) );
        
        }
        { //::osgText::Text::getColorGradientTopLeft
        
            typedef ::osg::Vec4 const & ( ::osgText::Text::*getColorGradientTopLeft_function_type)(  ) const;
            
            Text_exposer.def( 
                "getColorGradientTopLeft"
                , getColorGradientTopLeft_function_type( &::osgText::Text::getColorGradientTopLeft )
                , bp::return_internal_reference< >() );
        
        }
        { //::osgText::Text::getColorGradientTopRight
        
            typedef ::osg::Vec4 const & ( ::osgText::Text::*getColorGradientTopRight_function_type)(  ) const;
            
            Text_exposer.def( 
                "getColorGradientTopRight"
                , getColorGradientTopRight_function_type( &::osgText::Text::getColorGradientTopRight )
                , bp::return_internal_reference< >() );
        
        }
        { //::osgText::Text::getEnableDepthWrites
        
            typedef bool ( ::osgText::Text::*getEnableDepthWrites_function_type)(  ) const;
            
            Text_exposer.def( 
                "getEnableDepthWrites"
                , getEnableDepthWrites_function_type( &::osgText::Text::getEnableDepthWrites ) );
        
        }
        { //::osgText::Text::getGlyphQuads
        
            typedef ::osgText::Text::GlyphQuads const * ( ::osgText::Text::*getGlyphQuads_function_type)( ::osgText::GlyphTexture * ) const;
            
            Text_exposer.def( 
                "getGlyphQuads"
                , getGlyphQuads_function_type( &::osgText::Text::getGlyphQuads )
                , ( bp::arg("texture") )
                , bp::return_internal_reference< >()
                , " Direct Access to GlyphQuads" );
        
        }
        { //::osgText::Text::getTextureGlyphQuadMap
        
            typedef ::std::map< osg::ref_ptr<osgText::GlyphTexture>, osgText::Text::GlyphQuads > const & ( ::osgText::Text::*getTextureGlyphQuadMap_function_type)(  ) const;
            
            Text_exposer.def( 
                "getTextureGlyphQuadMap"
                , getTextureGlyphQuadMap_function_type( &::osgText::Text::getTextureGlyphQuadMap )
                , bp::return_internal_reference< >() );
        
        }
        { //::osgText::Text::isSameKindAs
        
            typedef bool ( ::osgText::Text::*isSameKindAs_function_type)( ::osg::Object const * ) const;
            typedef bool ( Text_wrapper::*default_isSameKindAs_function_type)( ::osg::Object const * ) const;
            
            Text_exposer.def( 
                "isSameKindAs"
                , isSameKindAs_function_type(&::osgText::Text::isSameKindAs)
                , default_isSameKindAs_function_type(&Text_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) );
        
        }
        { //::osgText::Text::libraryName
        
            typedef char const * ( ::osgText::Text::*libraryName_function_type)(  ) const;
            typedef char const * ( Text_wrapper::*default_libraryName_function_type)(  ) const;
            
            Text_exposer.def( 
                "libraryName"
                , libraryName_function_type(&::osgText::Text::libraryName)
                , default_libraryName_function_type(&Text_wrapper::default_libraryName) );
        
        }
        { //::osgText::Text::releaseGLObjects
        
            typedef void ( ::osgText::Text::*releaseGLObjects_function_type)( ::osg::State * ) const;
            typedef void ( Text_wrapper::*default_releaseGLObjects_function_type)( ::osg::State * ) const;
            
            Text_exposer.def( 
                "releaseGLObjects"
                , releaseGLObjects_function_type(&::osgText::Text::releaseGLObjects)
                , default_releaseGLObjects_function_type(&Text_wrapper::default_releaseGLObjects)
                , ( bp::arg("state")=bp::object() ) );
        
        }
        { //::osgText::Text::resizeGLObjectBuffers
        
            typedef void ( ::osgText::Text::*resizeGLObjectBuffers_function_type)( unsigned int ) ;
            typedef void ( Text_wrapper::*default_resizeGLObjectBuffers_function_type)( unsigned int ) ;
            
            Text_exposer.def( 
                "resizeGLObjectBuffers"
                , resizeGLObjectBuffers_function_type(&::osgText::Text::resizeGLObjectBuffers)
                , default_resizeGLObjectBuffers_function_type(&Text_wrapper::default_resizeGLObjectBuffers)
                , ( bp::arg("maxSize") ) );
        
        }
        { //::osgText::Text::setBackdropColor
        
            typedef void ( ::osgText::Text::*setBackdropColor_function_type)( ::osg::Vec4 const & ) ;
            
            Text_exposer.def( 
                "setBackdropColor"
                , setBackdropColor_function_type( &::osgText::Text::setBackdropColor )
                , ( bp::arg("color") )
                , " This specifies the color of the backdrop text.\n The default is black." );
        
        }
        { //::osgText::Text::setBackdropImplementation
        
            typedef void ( ::osgText::Text::*setBackdropImplementation_function_type)( ::osgText::Text::BackdropImplementation ) ;
            
            Text_exposer.def( 
                "setBackdropImplementation"
                , setBackdropImplementation_function_type( &::osgText::Text::setBackdropImplementation )
                , ( bp::arg("implementation") )
                , " This specifies the underlying backdrop rendering implementation.\n Unfortunately, at this time, there is no perfect rendering solution\n so this function is provided to let you pick your poison. Each\n implementation has trade-offs. See BackdropImplementation enum\n docs for details." );
        
        }
        { //::osgText::Text::setBackdropOffset
        
            typedef void ( ::osgText::Text::*setBackdropOffset_function_type)( float ) ;
            
            Text_exposer.def( 
                "setBackdropOffset"
                , setBackdropOffset_function_type( &::osgText::Text::setBackdropOffset )
                , ( bp::arg("offset")=7.0000000298023223876953125e-2f )
                , " Sets the amount text is offset to create the backdrop/shadow effect.\n Set the value too high and for example, in OUTLINE mode you will get a Brady Bunch\n effect where you see duplicates of the text in a 3x3 grid.\n Set the value too small and you wont see anything.\n The values represent percentages. 1.0 means 100% so a value of 1.0\n in DROW_SHADOW_LEFT_CENTER mode would cause each glyph to be echoed\n next to it self. So the letter e might look like ee.\n Good values tend to be in the 0.03 to 0.10 range (but will be subject\n to your specific font and display characteristics).\n Note that the text bounding boxes are updated to include backdrop offsets.\n However, other metric information such as getCharacterHeight() are unaffected\n by this. This means that individual glyph spacing (kerning?) are unchanged\n even when this mode is used.\n The default is 0.07 (7% offset)." );
        
        }
        { //::osgText::Text::setBackdropOffset
        
            typedef void ( ::osgText::Text::*setBackdropOffset_function_type)( float,float ) ;
            
            Text_exposer.def( 
                "setBackdropOffset"
                , setBackdropOffset_function_type( &::osgText::Text::setBackdropOffset )
                , ( bp::arg("horizontal"), bp::arg("vertical") )
                , " This overloaded version lets you specify the offset for the horizontal\n and vertical components separately." );
        
        }
        { //::osgText::Text::setBackdropType
        
            typedef void ( ::osgText::Text::*setBackdropType_function_type)( ::osgText::Text::BackdropType ) ;
            
            Text_exposer.def( 
                "setBackdropType"
                , setBackdropType_function_type( &::osgText::Text::setBackdropType )
                , ( bp::arg("type") )
                , " BackdropType gives you a background shadow text behind your regular\n text. This helps give text extra contrast which can be useful when\n placing text against noisy backgrounds.\n The color of the background shadow text is specified by setBackdropColor().\n DROP_SHADOW_BOTTOM_RIGHT will draw backdrop text to the right and down of\n the normal text. Other DROW_SHADOW_* modes do the same for their repective directions.\n OUTLINE will draw backdrop text so that it appears the text has an outline\n or border around the normal text. This mode is particularly useful against\n really noisy backgrounds that may put text on top of things that have\n all types of colors which you dont have control over.\n Some real world examples of this general technique in use that I know of\n are Google Earth, Sid Meiers Pirates (2004 Remake), and Star Control 2 (PC 1993).\n The default is NONE." );
        
        }
        { //::osgText::Text::setColorGradientCorners
        
            typedef void ( ::osgText::Text::*setColorGradientCorners_function_type)( ::osg::Vec4 const &,::osg::Vec4 const &,::osg::Vec4 const &,::osg::Vec4 const & ) ;
            
            Text_exposer.def( 
                "setColorGradientCorners"
                , setColorGradientCorners_function_type( &::osgText::Text::setColorGradientCorners )
                , ( bp::arg("topLeft"), bp::arg("bottomLeft"), bp::arg("bottomRight"), bp::arg("topRight") )
                , " Used only for gradient mode, lets you specify the colors of the 4 corners.\n If ColorGradients are off, these values are ignored (and the value from setColor()\n is the only one that is relevant." );
        
        }
        { //::osgText::Text::setColorGradientMode
        
            typedef void ( ::osgText::Text::*setColorGradientMode_function_type)( ::osgText::Text::ColorGradientMode ) ;
            
            Text_exposer.def( 
                "setColorGradientMode"
                , setColorGradientMode_function_type( &::osgText::Text::setColorGradientMode )
                , ( bp::arg("mode") )
                , " This sets different types of text coloring modes.\n When the coloring mode is not set to SOLID, the\n colors specified in setColorGradientCorners() determine\n the colors for the text.\n When the gradient mode is OVERALL, the coloring scheme\n attempts to approximate the effect as if the entire text box/region\n were a single polygon and you had applied colors to each of the four\n corners with GL_SMOOTH enabled. In this mode, OpenGL interpolates\n the colors across the polygon, and this is what OVERALL tries to\n emulate. This can be used to give nice embellishments on things\n like logos and names.\n PER_CHARACTER is similar to OVERALL except that it applies the\n color interpolation to the four corners of each character instead\n of across the overall text box.\n The default is SOLID (a.k.a. off)." );
        
        }
        { //::osgText::Text::setEnableDepthWrites
        
            typedef void ( ::osgText::Text::*setEnableDepthWrites_function_type)( bool ) ;
            
            Text_exposer.def( 
                "setEnableDepthWrites"
                , setEnableDepthWrites_function_type( &::osgText::Text::setEnableDepthWrites )
                , ( bp::arg("enable") )
                , " Turns off writing to the depth buffer when rendering text. This only affects text\n with no backdrop or text using the DELAYED_DEPTH_WRITES implementation, since\n the other backdrop implementations are really only useful for backwards\n compatibility and are not worth updating to utilize this flag." );
        
        }
        { //::osgText::Text::setFont
        
            typedef void ( ::osgText::Text::*setFont_function_type)( ::osgText::Font * ) ;
            typedef void ( Text_wrapper::*default_setFont_function_type)( ::osgText::Font * ) ;
            
            Text_exposer.def( 
                "setFont"
                , setFont_function_type(&::osgText::Text::setFont)
                , default_setFont_function_type(&Text_wrapper::default_setFont)
                , ( bp::arg("font")=bp::object() ) );
        
        }
        { //::osgText::Text::setFont
        
            typedef void ( ::osgText::Text::*setFont_function_type)( ::osg::ref_ptr< osgText::Font > ) ;
            typedef void ( Text_wrapper::*default_setFont_function_type)( ::osg::ref_ptr< osgText::Font > ) ;
            
            Text_exposer.def( 
                "setFont"
                , setFont_function_type(&::osgText::Text::setFont)
                , default_setFont_function_type(&Text_wrapper::default_setFont)
                , ( bp::arg("font") ) );
        
        }
        { //::osgText::Text::setFont
        
            typedef void ( ::osgText::Text::*setFont_function_type)( ::std::string const & ) ;
            typedef void ( Text_wrapper::*default_setFont_function_type)( ::std::string const & ) ;
            
            Text_exposer.def( 
                "setFont"
                , setFont_function_type(&::osgText::Text::setFont)
                , default_setFont_function_type(&Text_wrapper::default_setFont)
                , ( bp::arg("fontfile") ) );
        
        }
        { //::osgText::Text::setThreadSafeRefUnref
        
            typedef void ( ::osgText::Text::*setThreadSafeRefUnref_function_type)( bool ) ;
            typedef void ( Text_wrapper::*default_setThreadSafeRefUnref_function_type)( bool ) ;
            
            Text_exposer.def( 
                "setThreadSafeRefUnref"
                , setThreadSafeRefUnref_function_type(&::osgText::Text::setThreadSafeRefUnref)
                , default_setThreadSafeRefUnref_function_type(&Text_wrapper::default_setThreadSafeRefUnref)
                , ( bp::arg("threadSafe") ) );
        
        }
        { //::osgText::Text::supports
        
            typedef bool ( ::osgText::Text::*supports_function_type)( ::osg::Drawable::AttributeFunctor const & ) const;
            typedef bool ( Text_wrapper::*default_supports_function_type)( ::osg::Drawable::AttributeFunctor const & ) const;
            
            Text_exposer.def( 
                "supports"
                , supports_function_type(&::osgText::Text::supports)
                , default_supports_function_type(&Text_wrapper::default_supports)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osgText::Text::supports
        
            typedef bool ( ::osgText::Text::*supports_function_type)( ::osg::Drawable::ConstAttributeFunctor const & ) const;
            typedef bool ( Text_wrapper::*default_supports_function_type)( ::osg::Drawable::ConstAttributeFunctor const & ) const;
            
            Text_exposer.def( 
                "supports"
                , supports_function_type(&::osgText::Text::supports)
                , default_supports_function_type(&Text_wrapper::default_supports)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osgText::Text::supports
        
            typedef bool ( ::osgText::Text::*supports_function_type)( ::osg::PrimitiveFunctor const & ) const;
            typedef bool ( Text_wrapper::*default_supports_function_type)( ::osg::PrimitiveFunctor const & ) const;
            
            Text_exposer.def( 
                "supports"
                , supports_function_type(&::osgText::Text::supports)
                , default_supports_function_type(&Text_wrapper::default_supports)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osgText::TextBase::computeBound
        
            typedef ::osg::BoundingBox ( ::osgText::TextBase::*computeBound_function_type)(  ) const;
            typedef ::osg::BoundingBox ( Text_wrapper::*default_computeBound_function_type)(  ) const;
            
            Text_exposer.def( 
                "computeBound"
                , computeBound_function_type(&::osgText::TextBase::computeBound)
                , default_computeBound_function_type(&Text_wrapper::default_computeBound) );
        
        }
    }

}
