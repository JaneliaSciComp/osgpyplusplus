// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "wrap_referenced.h"
#include "barrieroperation.pypp.hpp"

namespace bp = boost::python;

struct BarrierOperation_wrapper : osg::BarrierOperation, bp::wrapper< osg::BarrierOperation > {

    BarrierOperation_wrapper(int numThreads, ::osg::BarrierOperation::PreBlockOp op=::osg::BarrierOperation::NO_OPERATION, bool keep=true )
    : osg::BarrierOperation( numThreads, op, keep )
      , bp::wrapper< osg::BarrierOperation >(){
        // constructor
    
    }

    virtual void operator()( ::osg::Object * object ) {
        if( bp::override func___call__ = this->get_override( "__call__" ) )
            func___call__( boost::python::ptr(object) );
        else{
            this->osg::BarrierOperation::operator()( boost::python::ptr(object) );
        }
    }
    
    void default___call__( ::osg::Object * object ) {
        osg::BarrierOperation::operator()( boost::python::ptr(object) );
    }

    virtual void release(  ) {
        if( bp::override func_release = this->get_override( "release" ) )
            func_release(  );
        else{
            this->osg::BarrierOperation::release(  );
        }
    }
    
    void default_release(  ) {
        osg::BarrierOperation::release( );
    }

    virtual void block( unsigned int numThreads=0 ) {
        if( bp::override func_block = this->get_override( "block" ) )
            func_block( numThreads );
        else{
            this->OpenThreads::Barrier::block( numThreads );
        }
    }
    
    void default_block( unsigned int numThreads=0 ) {
        OpenThreads::Barrier::block( numThreads );
    }

    virtual int numThreadsCurrentlyBlocked(  ) {
        if( bp::override func_numThreadsCurrentlyBlocked = this->get_override( "numThreadsCurrentlyBlocked" ) )
            return func_numThreadsCurrentlyBlocked(  );
        else{
            return this->OpenThreads::Barrier::numThreadsCurrentlyBlocked(  );
        }
    }
    
    int default_numThreadsCurrentlyBlocked(  ) {
        return OpenThreads::Barrier::numThreadsCurrentlyBlocked( );
    }

    virtual void reset(  ) {
        if( bp::override func_reset = this->get_override( "reset" ) )
            func_reset(  );
        else{
            this->OpenThreads::Barrier::reset(  );
        }
    }
    
    void default_reset(  ) {
        OpenThreads::Barrier::reset( );
    }

    virtual void setThreadSafeRefUnref( bool threadSafe ) {
        if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
            func_setThreadSafeRefUnref( threadSafe );
        else{
            this->osg::Referenced::setThreadSafeRefUnref( threadSafe );
        }
    }
    
    void default_setThreadSafeRefUnref( bool threadSafe ) {
        osg::Referenced::setThreadSafeRefUnref( threadSafe );
    }

};

void register_BarrierOperation_class(){

    { //::osg::BarrierOperation
        typedef bp::class_< BarrierOperation_wrapper, bp::bases< osg::Operation, OpenThreads::Barrier >, osg::ref_ptr< ::osg::BarrierOperation >, boost::noncopyable > BarrierOperation_exposer_t;
        BarrierOperation_exposer_t BarrierOperation_exposer = BarrierOperation_exposer_t( "BarrierOperation", bp::init< int, bp::optional< osg::BarrierOperation::PreBlockOp, bool > >(( bp::arg("numThreads"), bp::arg("op")=(long)(::osg::BarrierOperation::NO_OPERATION), bp::arg("keep")=(bool)(true) )) );
        bp::scope BarrierOperation_scope( BarrierOperation_exposer );
        bp::enum_< osg::BarrierOperation::PreBlockOp>("PreBlockOp")
            .value("NO_OPERATION", osg::BarrierOperation::NO_OPERATION)
            .value("GL_FLUSH", osg::BarrierOperation::GL_FLUSH)
            .value("GL_FINISH", osg::BarrierOperation::GL_FINISH)
            .export_values()
            ;
        bp::implicitly_convertible< int, osg::BarrierOperation >();
        { //::osg::BarrierOperation::operator()
        
            typedef void ( ::osg::BarrierOperation::*__call___function_type)( ::osg::Object * ) ;
            typedef void ( BarrierOperation_wrapper::*default___call___function_type)( ::osg::Object * ) ;
            
            BarrierOperation_exposer.def( 
                "__call__"
                , __call___function_type(&::osg::BarrierOperation::operator())
                , default___call___function_type(&BarrierOperation_wrapper::default___call__)
                , ( bp::arg("object") ) );
        
        }
        { //::osg::BarrierOperation::release
        
            typedef void ( ::osg::BarrierOperation::*release_function_type)(  ) ;
            typedef void ( BarrierOperation_wrapper::*default_release_function_type)(  ) ;
            
            BarrierOperation_exposer.def( 
                "release"
                , release_function_type(&::osg::BarrierOperation::release)
                , default_release_function_type(&BarrierOperation_wrapper::default_release) );
        
        }
        BarrierOperation_exposer.def_readwrite( "_preBlockOp", &osg::BarrierOperation::_preBlockOp );
        { //::OpenThreads::Barrier::block
        
            typedef void ( ::OpenThreads::Barrier::*block_function_type)( unsigned int ) ;
            typedef void ( BarrierOperation_wrapper::*default_block_function_type)( unsigned int ) ;
            
            BarrierOperation_exposer.def( 
                "block"
                , block_function_type(&::OpenThreads::Barrier::block)
                , default_block_function_type(&BarrierOperation_wrapper::default_block)
                , ( bp::arg("numThreads")=(unsigned int)(0) ) );
        
        }
        { //::OpenThreads::Barrier::numThreadsCurrentlyBlocked
        
            typedef int ( ::OpenThreads::Barrier::*numThreadsCurrentlyBlocked_function_type)(  ) ;
            typedef int ( BarrierOperation_wrapper::*default_numThreadsCurrentlyBlocked_function_type)(  ) ;
            
            BarrierOperation_exposer.def( 
                "numThreadsCurrentlyBlocked"
                , numThreadsCurrentlyBlocked_function_type(&::OpenThreads::Barrier::numThreadsCurrentlyBlocked)
                , default_numThreadsCurrentlyBlocked_function_type(&BarrierOperation_wrapper::default_numThreadsCurrentlyBlocked) );
        
        }
        { //::OpenThreads::Barrier::reset
        
            typedef void ( ::OpenThreads::Barrier::*reset_function_type)(  ) ;
            typedef void ( BarrierOperation_wrapper::*default_reset_function_type)(  ) ;
            
            BarrierOperation_exposer.def( 
                "reset"
                , reset_function_type(&::OpenThreads::Barrier::reset)
                , default_reset_function_type(&BarrierOperation_wrapper::default_reset) );
        
        }
        { //::osg::Referenced::setThreadSafeRefUnref
        
            typedef void ( ::osg::Referenced::*setThreadSafeRefUnref_function_type)( bool ) ;
            typedef void ( BarrierOperation_wrapper::*default_setThreadSafeRefUnref_function_type)( bool ) ;
            
            BarrierOperation_exposer.def( 
                "setThreadSafeRefUnref"
                , setThreadSafeRefUnref_function_type(&::osg::Referenced::setThreadSafeRefUnref)
                , default_setThreadSafeRefUnref_function_type(&BarrierOperation_wrapper::default_setThreadSafeRefUnref)
                , ( bp::arg("threadSafe") ) );
        
        }
    }

}
