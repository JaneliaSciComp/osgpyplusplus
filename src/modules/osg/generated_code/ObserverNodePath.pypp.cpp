// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "observernodepath.pypp.hpp"

namespace bp = boost::python;

void register_ObserverNodePath_class(){

    { //::osg::ObserverNodePath
        typedef bp::class_< osg::ObserverNodePath > ObserverNodePath_exposer_t;
        ObserverNodePath_exposer_t ObserverNodePath_exposer = ObserverNodePath_exposer_t( "ObserverNodePath", "\n ObserverNodePath is an observer class for tracking changes to a NodePath,\n that automatically invalidates it when nodes are deleted.\n", bp::init< >("\n ObserverNodePath is an observer class for tracking changes to a NodePath,\n that automatically invalidates it when nodes are deleted.\n") );
        bp::scope ObserverNodePath_scope( ObserverNodePath_exposer );
        ObserverNodePath_exposer.def( bp::init< osg::ObserverNodePath const & >(( bp::arg("rhs") )) );
        ObserverNodePath_exposer.def( bp::init< osg::NodePath const & >(( bp::arg("nodePath") )) );
        bp::implicitly_convertible< osg::NodePath const &, osg::ObserverNodePath >();
        { //::osg::ObserverNodePath::clearNodePath
        
            typedef void ( ::osg::ObserverNodePath::*clearNodePath_function_type )(  ) ;
            
            ObserverNodePath_exposer.def( 
                "clearNodePath"
                , clearNodePath_function_type( &::osg::ObserverNodePath::clearNodePath ) );
        
        }
        { //::osg::ObserverNodePath::empty
        
            typedef bool ( ::osg::ObserverNodePath::*empty_function_type )(  ) const;
            
            ObserverNodePath_exposer.def( 
                "empty"
                , empty_function_type( &::osg::ObserverNodePath::empty ) );
        
        }
        { //::osg::ObserverNodePath::getNodePath
        
            typedef bool ( ::osg::ObserverNodePath::*getNodePath_function_type )( ::osg::NodePath & ) const;
            
            ObserverNodePath_exposer.def( 
                "getNodePath"
                , getNodePath_function_type( &::osg::ObserverNodePath::getNodePath )
                , ( bp::arg("nodePath") )
                , "\n Get a lightweight NodePath that isnt thread safe but\n may be safely used in single threaded applications, or when\n its known that the NodePath wont be invalidated during usage\n of the NodePath. return true if NodePath is valid.\n" );
        
        }
        { //::osg::ObserverNodePath::getRefNodePath
        
            typedef bool ( ::osg::ObserverNodePath::*getRefNodePath_function_type )( ::osg::RefNodePath & ) const;
            
            ObserverNodePath_exposer.def( 
                "getRefNodePath"
                , getRefNodePath_function_type( &::osg::ObserverNodePath::getRefNodePath )
                , ( bp::arg("refNodePath") )
                , "\n Get a thread safe RefNodePath, return true if NodePath is valid.\n" );
        
        }
        { //::osg::ObserverNodePath::operator=
        
            typedef ::osg::ObserverNodePath & ( ::osg::ObserverNodePath::*assign_function_type )( ::osg::ObserverNodePath const & ) ;
            
            ObserverNodePath_exposer.def( 
                "assign"
                , assign_function_type( &::osg::ObserverNodePath::operator= )
                , ( bp::arg("rhs") )
                , bp::return_self< >() );
        
        }
        { //::osg::ObserverNodePath::setNodePath
        
            typedef void ( ::osg::ObserverNodePath::*setNodePath_function_type )( ::osg::RefNodePath const & ) ;
            
            ObserverNodePath_exposer.def( 
                "setNodePath"
                , setNodePath_function_type( &::osg::ObserverNodePath::setNodePath )
                , ( bp::arg("nodePath") ) );
        
        }
        { //::osg::ObserverNodePath::setNodePath
        
            typedef void ( ::osg::ObserverNodePath::*setNodePath_function_type )( ::osg::NodePath const & ) ;
            
            ObserverNodePath_exposer.def( 
                "setNodePath"
                , setNodePath_function_type( &::osg::ObserverNodePath::setNodePath )
                , ( bp::arg("nodePath") ) );
        
        }
        { //::osg::ObserverNodePath::setNodePathTo
        
            typedef void ( ::osg::ObserverNodePath::*setNodePathTo_function_type )( ::osg::Node * ) ;
            
            ObserverNodePath_exposer.def( 
                "setNodePathTo"
                , setNodePathTo_function_type( &::osg::ObserverNodePath::setNodePathTo )
                , ( bp::arg("node") )
                , "\n get the NodePath from the first parental chain back to root, plus the specified node.\n" );
        
        }
    }

}
