// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "mutex.pypp.hpp"

namespace bp = boost::python;

struct Mutex_wrapper : OpenThreads::Mutex, bp::wrapper< OpenThreads::Mutex > {

    Mutex_wrapper(::OpenThreads::Mutex::MutexType type=::OpenThreads::Mutex::MUTEX_NORMAL )
    : OpenThreads::Mutex( type )
      , bp::wrapper< OpenThreads::Mutex >(){
        // constructor
    
    }

    virtual int lock(  ) {
        if( bp::override func_lock = this->get_override( "lock" ) )
            return func_lock(  );
        else{
            return this->OpenThreads::Mutex::lock(  );
        }
    }
    
    int default_lock(  ) {
        return OpenThreads::Mutex::lock( );
    }

    virtual int trylock(  ) {
        if( bp::override func_trylock = this->get_override( "trylock" ) )
            return func_trylock(  );
        else{
            return this->OpenThreads::Mutex::trylock(  );
        }
    }
    
    int default_trylock(  ) {
        return OpenThreads::Mutex::trylock( );
    }

    virtual int unlock(  ) {
        if( bp::override func_unlock = this->get_override( "unlock" ) )
            return func_unlock(  );
        else{
            return this->OpenThreads::Mutex::unlock(  );
        }
    }
    
    int default_unlock(  ) {
        return OpenThreads::Mutex::unlock( );
    }

};

void register_Mutex_class(){

    { //::OpenThreads::Mutex
        typedef bp::class_< Mutex_wrapper, boost::noncopyable > Mutex_exposer_t;
        Mutex_exposer_t Mutex_exposer = Mutex_exposer_t( "Mutex", bp::init< bp::optional< OpenThreads::Mutex::MutexType > >(( bp::arg("type")=(long)(::OpenThreads::Mutex::MUTEX_NORMAL) )) );
        bp::scope Mutex_scope( Mutex_exposer );
        bp::enum_< OpenThreads::Mutex::MutexType>("MutexType")
            .value("MUTEX_NORMAL", OpenThreads::Mutex::MUTEX_NORMAL)
            .value("MUTEX_RECURSIVE", OpenThreads::Mutex::MUTEX_RECURSIVE)
            .export_values()
            ;
        bp::implicitly_convertible< OpenThreads::Mutex::MutexType, OpenThreads::Mutex >();
        { //::OpenThreads::Mutex::getMutexType
        
            typedef ::OpenThreads::Mutex::MutexType ( ::OpenThreads::Mutex::*getMutexType_function_type)(  ) const;
            
            Mutex_exposer.def( 
                "getMutexType"
                , getMutexType_function_type( &::OpenThreads::Mutex::getMutexType ) );
        
        }
        { //::OpenThreads::Mutex::lock
        
            typedef int ( ::OpenThreads::Mutex::*lock_function_type)(  ) ;
            typedef int ( Mutex_wrapper::*default_lock_function_type)(  ) ;
            
            Mutex_exposer.def( 
                "lock"
                , lock_function_type(&::OpenThreads::Mutex::lock)
                , default_lock_function_type(&Mutex_wrapper::default_lock) );
        
        }
        { //::OpenThreads::Mutex::trylock
        
            typedef int ( ::OpenThreads::Mutex::*trylock_function_type)(  ) ;
            typedef int ( Mutex_wrapper::*default_trylock_function_type)(  ) ;
            
            Mutex_exposer.def( 
                "trylock"
                , trylock_function_type(&::OpenThreads::Mutex::trylock)
                , default_trylock_function_type(&Mutex_wrapper::default_trylock) );
        
        }
        { //::OpenThreads::Mutex::unlock
        
            typedef int ( ::OpenThreads::Mutex::*unlock_function_type)(  ) ;
            typedef int ( Mutex_wrapper::*default_unlock_function_type)(  ) ;
            
            Mutex_exposer.def( 
                "unlock"
                , unlock_function_type(&::OpenThreads::Mutex::unlock)
                , default_unlock_function_type(&Mutex_wrapper::default_unlock) );
        
        }
    }

}
