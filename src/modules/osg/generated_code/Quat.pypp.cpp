// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "__convenience.pypp.hpp"
#include "wrap_osg.h"
#include "indexing_helpers.h"
#include "quat.pypp.hpp"

namespace bp = boost::python;

static boost::python::tuple getRotate_7cd433cce0eabe855a9b774688d2845e( ::osg::Quat const & inst ){
    double angle2;
    osg::Vec3f vec2;
    inst.getRotate(angle2, vec2);
    return bp::make_tuple( angle2, vec2 );
}

void register_Quat_class(){

    { //::osg::Quat
        typedef bp::class_< osg::Quat > Quat_exposer_t;
        Quat_exposer_t Quat_exposer = Quat_exposer_t( "Quat", "\n A quaternion class. It can be used to represent an orientation in 3D space.\n", bp::init< >() );
        bp::scope Quat_scope( Quat_exposer );
        Quat_exposer.def( bp::init< double, double, double, double >(( bp::arg("x"), bp::arg("y"), bp::arg("z"), bp::arg("w") )) );
        Quat_exposer.def( bp::init< osg::Vec4f const & >(( bp::arg("v") )) );
        bp::implicitly_convertible< osg::Vec4f const &, osg::Quat >();
        Quat_exposer.def( bp::init< osg::Vec4d const & >(( bp::arg("v") )) );
        bp::implicitly_convertible< osg::Vec4d const &, osg::Quat >();
        Quat_exposer.def( bp::init< double, osg::Vec3f const & >(( bp::arg("angle"), bp::arg("axis") )) );
        Quat_exposer.def( bp::init< double, osg::Vec3d const & >(( bp::arg("angle"), bp::arg("axis") )) );
        Quat_exposer.def( bp::init< double, osg::Vec3f const &, double, osg::Vec3f const &, double, osg::Vec3f const & >(( bp::arg("angle1"), bp::arg("axis1"), bp::arg("angle2"), bp::arg("axis2"), bp::arg("angle3"), bp::arg("axis3") )) );
        Quat_exposer.def( bp::init< double, osg::Vec3d const &, double, osg::Vec3d const &, double, osg::Vec3d const & >(( bp::arg("angle1"), bp::arg("axis1"), bp::arg("angle2"), bp::arg("axis2"), bp::arg("angle3"), bp::arg("axis3") )) );
        { //::osg::Quat::asVec3
        
            typedef ::osg::Vec3d ( ::osg::Quat::*asVec3_function_type)(  ) const;
            
            Quat_exposer.def( 
                "asVec3"
                , asVec3_function_type( &::osg::Quat::asVec3 ) );
        
        }
        { //::osg::Quat::asVec4
        
            typedef ::osg::Vec4d ( ::osg::Quat::*asVec4_function_type)(  ) const;
            
            Quat_exposer.def( 
                "asVec4"
                , asVec4_function_type( &::osg::Quat::asVec4 ) );
        
        }
        { //::osg::Quat::conj
        
            typedef ::osg::Quat ( ::osg::Quat::*conj_function_type)(  ) const;
            
            Quat_exposer.def( 
                "conj"
                , conj_function_type( &::osg::Quat::conj )
                , "\n Conjugate\n" );
        
        }
        { //::osg::Quat::get
        
            typedef void ( ::osg::Quat::*get_function_type)( ::osg::Matrixf & ) const;
            
            Quat_exposer.def( 
                "get"
                , get_function_type( &::osg::Quat::get )
                , ( bp::arg("matrix") ) );
        
        }
        { //::osg::Quat::get
        
            typedef void ( ::osg::Quat::*get_function_type)( ::osg::Matrixd & ) const;
            
            Quat_exposer.def( 
                "get"
                , get_function_type( &::osg::Quat::get )
                , ( bp::arg("matrix") ) );
        
        }
        { //::osg::Quat::getRotate
        
            typedef boost::python::tuple ( *getRotate_function_type )( ::osg::Quat const & );
            
            Quat_exposer.def( 
                "getRotate"
                , getRotate_function_type( &getRotate_7cd433cce0eabe855a9b774688d2845e )
                , ( bp::arg("inst") )
                , " Return the angle and vector represented by the quaternion." );
        
        }
        { //::osg::Quat::inverse
        
            typedef ::osg::Quat const ( ::osg::Quat::*inverse_function_type)(  ) const;
            
            Quat_exposer.def( 
                "inverse"
                , inverse_function_type( &::osg::Quat::inverse )
                , "\n Multiplicative inverse method: q^(-1) = q^*/(q.q^*)\n" );
        
        }
        { //::osg::Quat::length
        
            typedef double ( ::osg::Quat::*length_function_type)(  ) const;
            
            Quat_exposer.def( 
                "length"
                , length_function_type( &::osg::Quat::length )
                , "\n Length of the quaternion = sqrt( vec . vec )\n" );
        
        }
        { //::osg::Quat::length2
        
            typedef double ( ::osg::Quat::*length2_function_type)(  ) const;
            
            Quat_exposer.def( 
                "length2"
                , length2_function_type( &::osg::Quat::length2 )
                , "\n Length of the quaternion = vec . vec\n" );
        
        }
        { //::osg::Quat::makeRotate
        
            typedef void ( ::osg::Quat::*makeRotate_function_type)( double,double,double,double ) ;
            
            Quat_exposer.def( 
                "makeRotate"
                , makeRotate_function_type( &::osg::Quat::makeRotate )
                , ( bp::arg("angle"), bp::arg("x"), bp::arg("y"), bp::arg("z") ) );
        
        }
        { //::osg::Quat::makeRotate
        
            typedef void ( ::osg::Quat::*makeRotate_function_type)( double,::osg::Vec3f const & ) ;
            
            Quat_exposer.def( 
                "makeRotate"
                , makeRotate_function_type( &::osg::Quat::makeRotate )
                , ( bp::arg("angle"), bp::arg("vec") ) );
        
        }
        { //::osg::Quat::makeRotate
        
            typedef void ( ::osg::Quat::*makeRotate_function_type)( double,::osg::Vec3d const & ) ;
            
            Quat_exposer.def( 
                "makeRotate"
                , makeRotate_function_type( &::osg::Quat::makeRotate )
                , ( bp::arg("angle"), bp::arg("vec") ) );
        
        }
        { //::osg::Quat::makeRotate
        
            typedef void ( ::osg::Quat::*makeRotate_function_type)( double,::osg::Vec3f const &,double,::osg::Vec3f const &,double,::osg::Vec3f const & ) ;
            
            Quat_exposer.def( 
                "makeRotate"
                , makeRotate_function_type( &::osg::Quat::makeRotate )
                , ( bp::arg("angle1"), bp::arg("axis1"), bp::arg("angle2"), bp::arg("axis2"), bp::arg("angle3"), bp::arg("axis3") ) );
        
        }
        { //::osg::Quat::makeRotate
        
            typedef void ( ::osg::Quat::*makeRotate_function_type)( double,::osg::Vec3d const &,double,::osg::Vec3d const &,double,::osg::Vec3d const & ) ;
            
            Quat_exposer.def( 
                "makeRotate"
                , makeRotate_function_type( &::osg::Quat::makeRotate )
                , ( bp::arg("angle1"), bp::arg("axis1"), bp::arg("angle2"), bp::arg("axis2"), bp::arg("angle3"), bp::arg("axis3") ) );
        
        }
        { //::osg::Quat::makeRotate
        
            typedef void ( ::osg::Quat::*makeRotate_function_type)( ::osg::Vec3f const &,::osg::Vec3f const & ) ;
            
            Quat_exposer.def( 
                "makeRotate"
                , makeRotate_function_type( &::osg::Quat::makeRotate )
                , ( bp::arg("vec1"), bp::arg("vec2") )
                , "\n Make a rotation Quat which will rotate vec1 to vec2.\n            Generally take a dot product to get the angle between these\n            and then use a cross product to get the rotation axis\n            Watch out for the two special cases when the vectors\n            are co-incident or opposite in direction.\n" );
        
        }
        { //::osg::Quat::makeRotate
        
            typedef void ( ::osg::Quat::*makeRotate_function_type)( ::osg::Vec3d const &,::osg::Vec3d const & ) ;
            
            Quat_exposer.def( 
                "makeRotate"
                , makeRotate_function_type( &::osg::Quat::makeRotate )
                , ( bp::arg("vec1"), bp::arg("vec2") )
                , "\n Make a rotation Quat which will rotate vec1 to vec2.\n            Generally take a dot product to get the angle between these\n            and then use a cross product to get the rotation axis\n            Watch out for the two special cases of when the vectors\n            are co-incident or opposite in direction.\n" );
        
        }
        { //::osg::Quat::makeRotate_original
        
            typedef void ( ::osg::Quat::*makeRotate_original_function_type)( ::osg::Vec3d const &,::osg::Vec3d const & ) ;
            
            Quat_exposer.def( 
                "makeRotate_original"
                , makeRotate_original_function_type( &::osg::Quat::makeRotate_original )
                , ( bp::arg("vec1"), bp::arg("vec2") ) );
        
        }
        Quat_exposer.def( bp::self != bp::self );
        Quat_exposer.def( bp::self * bp::other< double >() );
        Quat_exposer.def( bp::self * bp::self );
        Quat_exposer.def( bp::self * bp::other< osg::Vec3f >() );
        Quat_exposer.def( bp::self * bp::other< osg::Vec3d >() );
        Quat_exposer.def( bp::self *= bp::other< double >() );
        Quat_exposer.def( bp::self *= bp::self );
        Quat_exposer.def( bp::self + bp::self );
        Quat_exposer.def( bp::self += bp::self );
        Quat_exposer.def( bp::self - bp::self );
        Quat_exposer.def( -bp::self );
        Quat_exposer.def( bp::self -= bp::self );
        Quat_exposer.def( bp::self / bp::other< double >() );
        Quat_exposer.def( bp::self / bp::self );
        Quat_exposer.def( bp::self /= bp::other< double >() );
        Quat_exposer.def( bp::self /= bp::self );
        Quat_exposer.def( bp::self < bp::self );
        { //::osg::Quat::operator=
        
            typedef ::osg::Quat & ( ::osg::Quat::*assign_function_type)( ::osg::Quat const & ) ;
            
            Quat_exposer.def( 
                "assign"
                , assign_function_type( &::osg::Quat::operator= )
                , ( bp::arg("v") )
                , bp::return_self< >() );
        
        }
        Quat_exposer.def( bp::self == bp::self );
        { //::osg::Quat::operator[]
        
            typedef double & ( ::osg::Quat::*__getitem___function_type)( int ) ;
            
            Quat_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::osg::Quat::operator[] )
                , ( bp::arg("i") )
                , bp::return_value_policy< bp::copy_non_const_reference >() );
        
        }
        { //::osg::Quat::operator[]
        
            typedef double ( ::osg::Quat::*__getitem___function_type)( int ) const;
            
            Quat_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::osg::Quat::operator[] )
                , ( bp::arg("i") ) );
        
        }
        { //::osg::Quat::set
        
            typedef void ( ::osg::Quat::*set_function_type)( double,double,double,double ) ;
            
            Quat_exposer.def( 
                "set"
                , set_function_type( &::osg::Quat::set )
                , ( bp::arg("x"), bp::arg("y"), bp::arg("z"), bp::arg("w") ) );
        
        }
        { //::osg::Quat::set
        
            typedef void ( ::osg::Quat::*set_function_type)( ::osg::Vec4f const & ) ;
            
            Quat_exposer.def( 
                "set"
                , set_function_type( &::osg::Quat::set )
                , ( bp::arg("v") ) );
        
        }
        { //::osg::Quat::set
        
            typedef void ( ::osg::Quat::*set_function_type)( ::osg::Vec4d const & ) ;
            
            Quat_exposer.def( 
                "set"
                , set_function_type( &::osg::Quat::set )
                , ( bp::arg("v") ) );
        
        }
        { //::osg::Quat::set
        
            typedef void ( ::osg::Quat::*set_function_type)( ::osg::Matrixf const & ) ;
            
            Quat_exposer.def( 
                "set"
                , set_function_type( &::osg::Quat::set )
                , ( bp::arg("matrix") ) );
        
        }
        { //::osg::Quat::set
        
            typedef void ( ::osg::Quat::*set_function_type)( ::osg::Matrixd const & ) ;
            
            Quat_exposer.def( 
                "set"
                , set_function_type( &::osg::Quat::set )
                , ( bp::arg("matrix") ) );
        
        }
        { //::osg::Quat::slerp
        
            typedef void ( ::osg::Quat::*slerp_function_type)( double,::osg::Quat const &,::osg::Quat const & ) ;
            
            Quat_exposer.def( 
                "slerp"
                , slerp_function_type( &::osg::Quat::slerp )
                , ( bp::arg("t"), bp::arg("from"), bp::arg("to") )
                , "\n Spherical Linear Interpolation.\n        As t goes from 0 to 1, the Quat object goes from from to to.\n" );
        
        }
        { //::osg::Quat::w
        
            typedef double & ( ::osg::Quat::*w_function_type)(  ) ;
            
            Quat_exposer.def( 
                "w"
                , w_function_type( &::osg::Quat::w )
                , bp::return_value_policy< bp::copy_non_const_reference >() );
        
        }
        { //::osg::Quat::w
        
            typedef double ( ::osg::Quat::*w_function_type)(  ) const;
            
            Quat_exposer.def( 
                "w"
                , w_function_type( &::osg::Quat::w ) );
        
        }
        { //::osg::Quat::x
        
            typedef double & ( ::osg::Quat::*x_function_type)(  ) ;
            
            Quat_exposer.def( 
                "x"
                , x_function_type( &::osg::Quat::x )
                , bp::return_value_policy< bp::copy_non_const_reference >() );
        
        }
        { //::osg::Quat::x
        
            typedef double ( ::osg::Quat::*x_function_type)(  ) const;
            
            Quat_exposer.def( 
                "x"
                , x_function_type( &::osg::Quat::x ) );
        
        }
        { //::osg::Quat::y
        
            typedef double & ( ::osg::Quat::*y_function_type)(  ) ;
            
            Quat_exposer.def( 
                "y"
                , y_function_type( &::osg::Quat::y )
                , bp::return_value_policy< bp::copy_non_const_reference >() );
        
        }
        { //::osg::Quat::y
        
            typedef double ( ::osg::Quat::*y_function_type)(  ) const;
            
            Quat_exposer.def( 
                "y"
                , y_function_type( &::osg::Quat::y ) );
        
        }
        { //::osg::Quat::z
        
            typedef double & ( ::osg::Quat::*z_function_type)(  ) ;
            
            Quat_exposer.def( 
                "z"
                , z_function_type( &::osg::Quat::z )
                , bp::return_value_policy< bp::copy_non_const_reference >() );
        
        }
        { //::osg::Quat::z
        
            typedef double ( ::osg::Quat::*z_function_type)(  ) const;
            
            Quat_exposer.def( 
                "z"
                , z_function_type( &::osg::Quat::z ) );
        
        }
        { //::osg::Quat::zeroRotation
        
            typedef bool ( ::osg::Quat::*zeroRotation_function_type)(  ) const;
            
            Quat_exposer.def( 
                "zeroRotation"
                , zeroRotation_function_type( &::osg::Quat::zeroRotation )
                , "\n return true if the Quat represents a zero rotation, and therefore can be ignored in computations.\n" );
        
        }
        Quat_exposer.def( bp::self_ns::str( bp::self ) );
        Quat_exposer.def( bp::self_ns::str(bp::self) );
        Quat_exposer.def(bp::indexing::container_suite<
                            osg::Quat, 
                            bp::indexing::all_methods, 
                            OsgVec_algorithms<osg::Quat, osg::Quat::value_type, 4> >());
    }

}
