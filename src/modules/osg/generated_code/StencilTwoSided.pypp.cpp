// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "wrap_osg.h"
#include "wrap_referenced.h"
#include "stenciltwosided.pypp.hpp"

namespace bp = boost::python;

struct StencilTwoSided_wrapper : osg::StencilTwoSided, bp::wrapper< osg::StencilTwoSided > {

    struct Extensions_wrapper : osg::StencilTwoSided::Extensions, bp::wrapper< osg::StencilTwoSided::Extensions > {
    
        Extensions_wrapper(unsigned int contextID )
        : osg::StencilTwoSided::Extensions( contextID )
          , bp::wrapper< osg::StencilTwoSided::Extensions >(){
            // constructor
        
        }
    
        static void lowestCommonDenominator( ::osg::StencilTwoSided::Extensions & inst, ::osg::StencilTwoSided::Extensions & rhs ){
            inst.lowestCommonDenominator(rhs);
        }
    
        virtual void setThreadSafeRefUnref( bool threadSafe ) {
            if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
                func_setThreadSafeRefUnref( threadSafe );
            else{
                this->osg::Referenced::setThreadSafeRefUnref( threadSafe );
            }
        }
        
        void default_setThreadSafeRefUnref( bool threadSafe ) {
            osg::Referenced::setThreadSafeRefUnref( threadSafe );
        }
    
    };

    StencilTwoSided_wrapper( )
    : osg::StencilTwoSided( )
      , bp::wrapper< osg::StencilTwoSided >(){
        // null constructor
    
    }

    virtual void apply( ::osg::State & state ) const  {
        if( bp::override func_apply = this->get_override( "apply" ) )
            func_apply( boost::ref(state) );
        else{
            this->osg::StencilTwoSided::apply( boost::ref(state) );
        }
    }
    
    void default_apply( ::osg::State & state ) const  {
        osg::StencilTwoSided::apply( boost::ref(state) );
    }

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osg::StencilTwoSided::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osg::StencilTwoSided::className( );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone( boost::ref(copyop) );
        else{
            return this->osg::StencilTwoSided::clone( boost::ref(copyop) );
        }
    }
    
    ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
        return osg::StencilTwoSided::clone( boost::ref(copyop) );
    }

    virtual ::osg::Object * cloneType(  ) const  {
        if( bp::override func_cloneType = this->get_override( "cloneType" ) )
            return func_cloneType(  );
        else{
            return this->osg::StencilTwoSided::cloneType(  );
        }
    }
    
    ::osg::Object * default_cloneType(  ) const  {
        return osg::StencilTwoSided::cloneType( );
    }

    virtual bool getModeUsage( ::osg::StateAttribute::ModeUsage & usage ) const  {
        if( bp::override func_getModeUsage = this->get_override( "getModeUsage" ) )
            return func_getModeUsage( boost::ref(usage) );
        else{
            return this->osg::StencilTwoSided::getModeUsage( boost::ref(usage) );
        }
    }
    
    bool default_getModeUsage( ::osg::StateAttribute::ModeUsage & usage ) const  {
        return osg::StencilTwoSided::getModeUsage( boost::ref(usage) );
    }

    virtual ::osg::StateAttribute::Type getType(  ) const  {
        if( bp::override func_getType = this->get_override( "getType" ) )
            return func_getType(  );
        else{
            return this->osg::StencilTwoSided::getType(  );
        }
    }
    
    ::osg::StateAttribute::Type default_getType(  ) const  {
        return osg::StencilTwoSided::getType( );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osg::StencilTwoSided::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osg::StencilTwoSided::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osg::StencilTwoSided::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osg::StencilTwoSided::libraryName( );
    }

    virtual ::osg::Texture * asTexture(  ) {
        if( bp::override func_asTexture = this->get_override( "asTexture" ) )
            return func_asTexture(  );
        else{
            return this->osg::StateAttribute::asTexture(  );
        }
    }
    
    ::osg::Texture * default_asTexture(  ) {
        return osg::StateAttribute::asTexture( );
    }

    virtual ::osg::Texture const * asTexture(  ) const  {
        if( bp::override func_asTexture = this->get_override( "asTexture" ) )
            return func_asTexture(  );
        else{
            return this->osg::StateAttribute::asTexture(  );
        }
    }
    
    ::osg::Texture const * default_asTexture(  ) const  {
        return osg::StateAttribute::asTexture( );
    }

    virtual bool checkValidityOfAssociatedModes( ::osg::State & arg0 ) const  {
        if( bp::override func_checkValidityOfAssociatedModes = this->get_override( "checkValidityOfAssociatedModes" ) )
            return func_checkValidityOfAssociatedModes( boost::ref(arg0) );
        else{
            return this->osg::StateAttribute::checkValidityOfAssociatedModes( boost::ref(arg0) );
        }
    }
    
    bool default_checkValidityOfAssociatedModes( ::osg::State & arg0 ) const  {
        return osg::StateAttribute::checkValidityOfAssociatedModes( boost::ref(arg0) );
    }

    virtual void compileGLObjects( ::osg::State & arg0 ) const  {
        if( bp::override func_compileGLObjects = this->get_override( "compileGLObjects" ) )
            func_compileGLObjects( boost::ref(arg0) );
        else{
            this->osg::StateAttribute::compileGLObjects( boost::ref(arg0) );
        }
    }
    
    void default_compileGLObjects( ::osg::State & arg0 ) const  {
        osg::StateAttribute::compileGLObjects( boost::ref(arg0) );
    }

    virtual void computeDataVariance(  ) {
        if( bp::override func_computeDataVariance = this->get_override( "computeDataVariance" ) )
            func_computeDataVariance(  );
        else{
            this->osg::Object::computeDataVariance(  );
        }
    }
    
    void default_computeDataVariance(  ) {
        osg::Object::computeDataVariance( );
    }

    virtual unsigned int getMember(  ) const  {
        if( bp::override func_getMember = this->get_override( "getMember" ) )
            return func_getMember(  );
        else{
            return this->osg::StateAttribute::getMember(  );
        }
    }
    
    unsigned int default_getMember(  ) const  {
        return osg::StateAttribute::getMember( );
    }

    virtual ::osg::Referenced * getUserData(  ) {
        if( bp::override func_getUserData = this->get_override( "getUserData" ) )
            return func_getUserData(  );
        else{
            return this->osg::Object::getUserData(  );
        }
    }
    
    ::osg::Referenced * default_getUserData(  ) {
        return osg::Object::getUserData( );
    }

    virtual ::osg::Referenced const * getUserData(  ) const  {
        if( bp::override func_getUserData = this->get_override( "getUserData" ) )
            return func_getUserData(  );
        else{
            return this->osg::Object::getUserData(  );
        }
    }
    
    ::osg::Referenced const * default_getUserData(  ) const  {
        return osg::Object::getUserData( );
    }

    virtual bool isTextureAttribute(  ) const  {
        if( bp::override func_isTextureAttribute = this->get_override( "isTextureAttribute" ) )
            return func_isTextureAttribute(  );
        else{
            return this->osg::StateAttribute::isTextureAttribute(  );
        }
    }
    
    bool default_isTextureAttribute(  ) const  {
        return osg::StateAttribute::isTextureAttribute( );
    }

    virtual void resizeGLObjectBuffers( unsigned int arg0 ) {
        if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
            func_resizeGLObjectBuffers( arg0 );
        else{
            this->osg::StateAttribute::resizeGLObjectBuffers( arg0 );
        }
    }
    
    void default_resizeGLObjectBuffers( unsigned int arg0 ) {
        osg::StateAttribute::resizeGLObjectBuffers( arg0 );
    }

    virtual void setName( ::std::string const & name ) {
        if( bp::override func_setName = this->get_override( "setName" ) )
            func_setName( name );
        else{
            this->osg::Object::setName( name );
        }
    }
    
    void default_setName( ::std::string const & name ) {
        osg::Object::setName( name );
    }

    virtual void setThreadSafeRefUnref( bool threadSafe ) {
        if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
            func_setThreadSafeRefUnref( threadSafe );
        else{
            this->osg::Object::setThreadSafeRefUnref( threadSafe );
        }
    }
    
    void default_setThreadSafeRefUnref( bool threadSafe ) {
        osg::Object::setThreadSafeRefUnref( threadSafe );
    }

    virtual void setUserData( ::osg::Referenced * obj ) {
        if( bp::override func_setUserData = this->get_override( "setUserData" ) )
            func_setUserData( boost::python::ptr(obj) );
        else{
            this->osg::Object::setUserData( boost::python::ptr(obj) );
        }
    }
    
    void default_setUserData( ::osg::Referenced * obj ) {
        osg::Object::setUserData( boost::python::ptr(obj) );
    }

};

void register_StencilTwoSided_class(){

    { //::osg::StencilTwoSided
        typedef bp::class_< StencilTwoSided_wrapper, bp::bases< osg::StateAttribute >, osg::ref_ptr< StencilTwoSided_wrapper >, boost::noncopyable > StencilTwoSided_exposer_t;
        StencilTwoSided_exposer_t StencilTwoSided_exposer = StencilTwoSided_exposer_t( "StencilTwoSided", "\n Provides OpenGL two sided stencil functionality, also known as separate stencil.\n  It enables to specify different stencil function for front and back facing polygons.\n  Two sided stenciling is used usually to eliminate the need of two rendering passes\n  when using standard stenciling functions. See also aa osg::Stencil.\n\n  Two sided stenciling is available since OpenGL 2.0. It is also supported by\n  EXT_stencil_two_side extension especially on Nvidia cards.\n  Another extension introduced by ATI is ATI_separate_stencil. However, ATIs extension\n  is limited to have reference and mask value the same for both faces.\n  ATIs extension is currently not supported by the current implementation.\n\n  osg::StencilTwoSided does nothing if OpenGL 2.0 or EXT_stencil_two_side are not available.\n", bp::no_init );
        bp::scope StencilTwoSided_scope( StencilTwoSided_exposer );
        bp::enum_< osg::StencilTwoSided::Face>("Face")
            .value("FRONT", osg::StencilTwoSided::FRONT)
            .value("BACK", osg::StencilTwoSided::BACK)
            .export_values()
            ;
        bp::enum_< osg::StencilTwoSided::Function>("Function")
            .value("NEVER", osg::StencilTwoSided::NEVER)
            .value("LESS", osg::StencilTwoSided::LESS)
            .value("EQUAL", osg::StencilTwoSided::EQUAL)
            .value("LEQUAL", osg::StencilTwoSided::LEQUAL)
            .value("GREATER", osg::StencilTwoSided::GREATER)
            .value("NOTEQUAL", osg::StencilTwoSided::NOTEQUAL)
            .value("GEQUAL", osg::StencilTwoSided::GEQUAL)
            .value("ALWAYS", osg::StencilTwoSided::ALWAYS)
            .export_values()
            ;
        bp::enum_< osg::StencilTwoSided::Operation>("Operation")
            .value("KEEP", osg::StencilTwoSided::KEEP)
            .value("ZERO", osg::StencilTwoSided::ZERO)
            .value("REPLACE", osg::StencilTwoSided::REPLACE)
            .value("INCR", osg::StencilTwoSided::INCR)
            .value("DECR", osg::StencilTwoSided::DECR)
            .value("INVERT", osg::StencilTwoSided::INVERT)
            .value("INCR_WRAP", osg::StencilTwoSided::INCR_WRAP)
            .value("DECR_WRAP", osg::StencilTwoSided::DECR_WRAP)
            .export_values()
            ;
        { //::osg::StencilTwoSided::Extensions
            typedef bp::class_< StencilTwoSided_wrapper::Extensions_wrapper, bp::bases< osg::Referenced >, osg::ref_ptr< ::osg::StencilTwoSided::Extensions > > Extensions_exposer_t;
            Extensions_exposer_t Extensions_exposer = Extensions_exposer_t( "Extensions", "\n Extensions class which encapsulates the querying of extensions and\n associated function pointers, and provide convenience wrappers to\n check for the extensions or use the associated functions.\n", bp::no_init );
            bp::scope Extensions_scope( Extensions_exposer );
            Extensions_exposer.def( bp::init< unsigned int >(( bp::arg("contextID") ), "\n Extensions class which encapsulates the querying of extensions and\n associated function pointers, and provide convenience wrappers to\n check for the extensions or use the associated functions.\n") );
            bp::implicitly_convertible< unsigned int, osg::StencilTwoSided::Extensions >();
            { //::osg::StencilTwoSided::Extensions::glActiveStencilFace
            
                typedef void ( ::osg::StencilTwoSided::Extensions::*glActiveStencilFace_function_type)( ::GLenum ) const;
                
                Extensions_exposer.def( 
                    "glActiveStencilFace"
                    , glActiveStencilFace_function_type( &::osg::StencilTwoSided::Extensions::glActiveStencilFace )
                    , ( bp::arg("face") ) );
            
            }
            { //::osg::StencilTwoSided::Extensions::glStencilFuncSeparate
            
                typedef void ( ::osg::StencilTwoSided::Extensions::*glStencilFuncSeparate_function_type)( ::GLenum,::GLenum,::GLint,::GLuint ) const;
                
                Extensions_exposer.def( 
                    "glStencilFuncSeparate"
                    , glStencilFuncSeparate_function_type( &::osg::StencilTwoSided::Extensions::glStencilFuncSeparate )
                    , ( bp::arg("face"), bp::arg("func"), bp::arg("ref"), bp::arg("mask") ) );
            
            }
            { //::osg::StencilTwoSided::Extensions::glStencilFuncSeparateATI
            
                typedef void ( ::osg::StencilTwoSided::Extensions::*glStencilFuncSeparateATI_function_type)( ::GLenum,::GLenum,::GLint,::GLuint ) const;
                
                Extensions_exposer.def( 
                    "glStencilFuncSeparateATI"
                    , glStencilFuncSeparateATI_function_type( &::osg::StencilTwoSided::Extensions::glStencilFuncSeparateATI )
                    , ( bp::arg("frontfunc"), bp::arg("backfunc"), bp::arg("ref"), bp::arg("mask") ) );
            
            }
            { //::osg::StencilTwoSided::Extensions::glStencilMaskSeparate
            
                typedef void ( ::osg::StencilTwoSided::Extensions::*glStencilMaskSeparate_function_type)( ::GLenum,::GLuint ) const;
                
                Extensions_exposer.def( 
                    "glStencilMaskSeparate"
                    , glStencilMaskSeparate_function_type( &::osg::StencilTwoSided::Extensions::glStencilMaskSeparate )
                    , ( bp::arg("face"), bp::arg("mask") ) );
            
            }
            { //::osg::StencilTwoSided::Extensions::glStencilOpSeparate
            
                typedef void ( ::osg::StencilTwoSided::Extensions::*glStencilOpSeparate_function_type)( ::GLenum,::GLenum,::GLenum,::GLenum ) const;
                
                Extensions_exposer.def( 
                    "glStencilOpSeparate"
                    , glStencilOpSeparate_function_type( &::osg::StencilTwoSided::Extensions::glStencilOpSeparate )
                    , ( bp::arg("face"), bp::arg("sfail"), bp::arg("dpfail"), bp::arg("dppass") ) );
            
            }
            { //::osg::StencilTwoSided::Extensions::isOpenGL20Supported
            
                typedef bool ( ::osg::StencilTwoSided::Extensions::*isOpenGL20Supported_function_type)(  ) const;
                
                Extensions_exposer.def( 
                    "isOpenGL20Supported"
                    , isOpenGL20Supported_function_type( &::osg::StencilTwoSided::Extensions::isOpenGL20Supported ) );
            
            }
            { //::osg::StencilTwoSided::Extensions::isSeparateStencilSupported
            
                typedef bool ( ::osg::StencilTwoSided::Extensions::*isSeparateStencilSupported_function_type)(  ) const;
                
                Extensions_exposer.def( 
                    "isSeparateStencilSupported"
                    , isSeparateStencilSupported_function_type( &::osg::StencilTwoSided::Extensions::isSeparateStencilSupported ) );
            
            }
            { //::osg::StencilTwoSided::Extensions::isStencilTwoSidedSupported
            
                typedef bool ( ::osg::StencilTwoSided::Extensions::*isStencilTwoSidedSupported_function_type)(  ) const;
                
                Extensions_exposer.def( 
                    "isStencilTwoSidedSupported"
                    , isStencilTwoSidedSupported_function_type( &::osg::StencilTwoSided::Extensions::isStencilTwoSidedSupported ) );
            
            }
            { //::osg::StencilTwoSided::Extensions::lowestCommonDenominator
            
                typedef void ( *lowestCommonDenominator_function_type )( ::osg::StencilTwoSided::Extensions &,::osg::StencilTwoSided::Extensions & );
                
                Extensions_exposer.def( 
                    "lowestCommonDenominator"
                    , lowestCommonDenominator_function_type( &StencilTwoSided_wrapper::Extensions_wrapper::lowestCommonDenominator )
                    , ( bp::arg("inst"), bp::arg("rhs") ) );
            
            }
            { //::osg::StencilTwoSided::Extensions::setOpenGL20Supported
            
                typedef void ( ::osg::StencilTwoSided::Extensions::*setOpenGL20Supported_function_type)( bool ) ;
                
                Extensions_exposer.def( 
                    "setOpenGL20Supported"
                    , setOpenGL20Supported_function_type( &::osg::StencilTwoSided::Extensions::setOpenGL20Supported )
                    , ( bp::arg("flag") ) );
            
            }
            { //::osg::StencilTwoSided::Extensions::setSeparateStencilSupported
            
                typedef void ( ::osg::StencilTwoSided::Extensions::*setSeparateStencilSupported_function_type)( bool ) ;
                
                Extensions_exposer.def( 
                    "setSeparateStencilSupported"
                    , setSeparateStencilSupported_function_type( &::osg::StencilTwoSided::Extensions::setSeparateStencilSupported )
                    , ( bp::arg("flag") ) );
            
            }
            { //::osg::StencilTwoSided::Extensions::setStencilTwoSidedSupported
            
                typedef void ( ::osg::StencilTwoSided::Extensions::*setStencilTwoSidedSupported_function_type)( bool ) ;
                
                Extensions_exposer.def( 
                    "setStencilTwoSidedSupported"
                    , setStencilTwoSidedSupported_function_type( &::osg::StencilTwoSided::Extensions::setStencilTwoSidedSupported )
                    , ( bp::arg("flag") ) );
            
            }
            { //::osg::StencilTwoSided::Extensions::setupGLExtensions
            
                typedef void ( ::osg::StencilTwoSided::Extensions::*setupGLExtensions_function_type)( unsigned int ) ;
                
                Extensions_exposer.def( 
                    "setupGLExtensions"
                    , setupGLExtensions_function_type( &::osg::StencilTwoSided::Extensions::setupGLExtensions )
                    , ( bp::arg("contextID") ) );
            
            }
            { //::osg::Referenced::setThreadSafeRefUnref
            
                typedef void ( ::osg::Referenced::*setThreadSafeRefUnref_function_type)( bool ) ;
                typedef void ( StencilTwoSided_wrapper::Extensions_wrapper::*default_setThreadSafeRefUnref_function_type)( bool ) ;
                
                Extensions_exposer.def( 
                    "setThreadSafeRefUnref"
                    , setThreadSafeRefUnref_function_type(&::osg::Referenced::setThreadSafeRefUnref)
                    , default_setThreadSafeRefUnref_function_type(&StencilTwoSided_wrapper::Extensions_wrapper::default_setThreadSafeRefUnref)
                    , ( bp::arg("threadSafe") ) );
            
            }
        }
        StencilTwoSided_exposer.def( bp::init< >("\n Provides OpenGL two sided stencil functionality, also known as separate stencil.\n  It enables to specify different stencil function for front and back facing polygons.\n  Two sided stenciling is used usually to eliminate the need of two rendering passes\n  when using standard stenciling functions. See also aa osg::Stencil.\n\n  Two sided stenciling is available since OpenGL 2.0. It is also supported by\n  EXT_stencil_two_side extension especially on Nvidia cards.\n  Another extension introduced by ATI is ATI_separate_stencil. However, ATIs extension\n  is limited to have reference and mask value the same for both faces.\n  ATIs extension is currently not supported by the current implementation.\n\n  osg::StencilTwoSided does nothing if OpenGL 2.0 or EXT_stencil_two_side are not available.\n") );
        { //::osg::StencilTwoSided::apply
        
            typedef void ( ::osg::StencilTwoSided::*apply_function_type)( ::osg::State & ) const;
            typedef void ( StencilTwoSided_wrapper::*default_apply_function_type)( ::osg::State & ) const;
            
            StencilTwoSided_exposer.def( 
                "apply"
                , apply_function_type(&::osg::StencilTwoSided::apply)
                , default_apply_function_type(&StencilTwoSided_wrapper::default_apply)
                , ( bp::arg("state") ) );
        
        }
        { //::osg::StencilTwoSided::className
        
            typedef char const * ( ::osg::StencilTwoSided::*className_function_type)(  ) const;
            typedef char const * ( StencilTwoSided_wrapper::*default_className_function_type)(  ) const;
            
            StencilTwoSided_exposer.def( 
                "className"
                , className_function_type(&::osg::StencilTwoSided::className)
                , default_className_function_type(&StencilTwoSided_wrapper::default_className) );
        
        }
        { //::osg::StencilTwoSided::clone
        
            typedef ::osg::Object * ( ::osg::StencilTwoSided::*clone_function_type)( ::osg::CopyOp const & ) const;
            typedef ::osg::Object * ( StencilTwoSided_wrapper::*default_clone_function_type)( ::osg::CopyOp const & ) const;
            
            StencilTwoSided_exposer.def( 
                "clone"
                , clone_function_type(&::osg::StencilTwoSided::clone)
                , default_clone_function_type(&StencilTwoSided_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::StencilTwoSided::cloneType
        
            typedef ::osg::Object * ( ::osg::StencilTwoSided::*cloneType_function_type)(  ) const;
            typedef ::osg::Object * ( StencilTwoSided_wrapper::*default_cloneType_function_type)(  ) const;
            
            StencilTwoSided_exposer.def( 
                "cloneType"
                , cloneType_function_type(&::osg::StencilTwoSided::cloneType)
                , default_cloneType_function_type(&StencilTwoSided_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::StencilTwoSided::getExtensions
        
            typedef ::osg::StencilTwoSided::Extensions * ( *getExtensions_function_type )( unsigned int,bool );
            
            StencilTwoSided_exposer.def( 
                "getExtensions"
                , getExtensions_function_type( &::osg::StencilTwoSided::getExtensions )
                , ( bp::arg("contextID"), bp::arg("createIfNotInitalized") )
                , bp::return_internal_reference< >()
                , " Function to call to get the extension of a specified context.\n If the Extension object for that context has not yet been created\n and the createIfNotInitalized flag been set to false then returns NULL.\n If createIfNotInitalized is true then the Extensions object is\n automatically created. However, in this case the extension object\n will only be created with the graphics context associated with ContextID." );
        
        }
        { //::osg::StencilTwoSided::getFunction
        
            typedef ::osg::StencilTwoSided::Function ( ::osg::StencilTwoSided::*getFunction_function_type)( ::osg::StencilTwoSided::Face ) const;
            
            StencilTwoSided_exposer.def( 
                "getFunction"
                , getFunction_function_type( &::osg::StencilTwoSided::getFunction )
                , ( bp::arg("face") ) );
        
        }
        { //::osg::StencilTwoSided::getFunctionMask
        
            typedef unsigned int ( ::osg::StencilTwoSided::*getFunctionMask_function_type)( ::osg::StencilTwoSided::Face ) const;
            
            StencilTwoSided_exposer.def( 
                "getFunctionMask"
                , getFunctionMask_function_type( &::osg::StencilTwoSided::getFunctionMask )
                , ( bp::arg("face") ) );
        
        }
        { //::osg::StencilTwoSided::getFunctionRef
        
            typedef int ( ::osg::StencilTwoSided::*getFunctionRef_function_type)( ::osg::StencilTwoSided::Face ) const;
            
            StencilTwoSided_exposer.def( 
                "getFunctionRef"
                , getFunctionRef_function_type( &::osg::StencilTwoSided::getFunctionRef )
                , ( bp::arg("face") ) );
        
        }
        { //::osg::StencilTwoSided::getModeUsage
        
            typedef bool ( ::osg::StencilTwoSided::*getModeUsage_function_type)( ::osg::StateAttribute::ModeUsage & ) const;
            typedef bool ( StencilTwoSided_wrapper::*default_getModeUsage_function_type)( ::osg::StateAttribute::ModeUsage & ) const;
            
            StencilTwoSided_exposer.def( 
                "getModeUsage"
                , getModeUsage_function_type(&::osg::StencilTwoSided::getModeUsage)
                , default_getModeUsage_function_type(&StencilTwoSided_wrapper::default_getModeUsage)
                , ( bp::arg("usage") ) );
        
        }
        { //::osg::StencilTwoSided::getStencilFailOperation
        
            typedef ::osg::StencilTwoSided::Operation ( ::osg::StencilTwoSided::*getStencilFailOperation_function_type)( ::osg::StencilTwoSided::Face ) const;
            
            StencilTwoSided_exposer.def( 
                "getStencilFailOperation"
                , getStencilFailOperation_function_type( &::osg::StencilTwoSided::getStencilFailOperation )
                , ( bp::arg("face") )
                , " get the operation when the stencil test fails." );
        
        }
        { //::osg::StencilTwoSided::getStencilPassAndDepthFailOperation
        
            typedef ::osg::StencilTwoSided::Operation ( ::osg::StencilTwoSided::*getStencilPassAndDepthFailOperation_function_type)( ::osg::StencilTwoSided::Face ) const;
            
            StencilTwoSided_exposer.def( 
                "getStencilPassAndDepthFailOperation"
                , getStencilPassAndDepthFailOperation_function_type( &::osg::StencilTwoSided::getStencilPassAndDepthFailOperation )
                , ( bp::arg("face") )
                , " get the operation when the stencil test passes but the depth test fails." );
        
        }
        { //::osg::StencilTwoSided::getStencilPassAndDepthPassOperation
        
            typedef ::osg::StencilTwoSided::Operation ( ::osg::StencilTwoSided::*getStencilPassAndDepthPassOperation_function_type)( ::osg::StencilTwoSided::Face ) const;
            
            StencilTwoSided_exposer.def( 
                "getStencilPassAndDepthPassOperation"
                , getStencilPassAndDepthPassOperation_function_type( &::osg::StencilTwoSided::getStencilPassAndDepthPassOperation )
                , ( bp::arg("face") )
                , " get the operation when both the stencil test and the depth test pass." );
        
        }
        { //::osg::StencilTwoSided::getType
        
            typedef ::osg::StateAttribute::Type ( ::osg::StencilTwoSided::*getType_function_type)(  ) const;
            typedef ::osg::StateAttribute::Type ( StencilTwoSided_wrapper::*default_getType_function_type)(  ) const;
            
            StencilTwoSided_exposer.def( 
                "getType"
                , getType_function_type(&::osg::StencilTwoSided::getType)
                , default_getType_function_type(&StencilTwoSided_wrapper::default_getType) );
        
        }
        { //::osg::StencilTwoSided::getWriteMask
        
            typedef unsigned int ( ::osg::StencilTwoSided::*getWriteMask_function_type)( ::osg::StencilTwoSided::Face ) const;
            
            StencilTwoSided_exposer.def( 
                "getWriteMask"
                , getWriteMask_function_type( &::osg::StencilTwoSided::getWriteMask )
                , ( bp::arg("face") ) );
        
        }
        { //::osg::StencilTwoSided::isSameKindAs
        
            typedef bool ( ::osg::StencilTwoSided::*isSameKindAs_function_type)( ::osg::Object const * ) const;
            typedef bool ( StencilTwoSided_wrapper::*default_isSameKindAs_function_type)( ::osg::Object const * ) const;
            
            StencilTwoSided_exposer.def( 
                "isSameKindAs"
                , isSameKindAs_function_type(&::osg::StencilTwoSided::isSameKindAs)
                , default_isSameKindAs_function_type(&StencilTwoSided_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) );
        
        }
        { //::osg::StencilTwoSided::libraryName
        
            typedef char const * ( ::osg::StencilTwoSided::*libraryName_function_type)(  ) const;
            typedef char const * ( StencilTwoSided_wrapper::*default_libraryName_function_type)(  ) const;
            
            StencilTwoSided_exposer.def( 
                "libraryName"
                , libraryName_function_type(&::osg::StencilTwoSided::libraryName)
                , default_libraryName_function_type(&StencilTwoSided_wrapper::default_libraryName) );
        
        }
        { //::osg::StencilTwoSided::setExtensions
        
            typedef void ( *setExtensions_function_type )( unsigned int,::osg::StencilTwoSided::Extensions * );
            
            StencilTwoSided_exposer.def( 
                "setExtensions"
                , setExtensions_function_type( &::osg::StencilTwoSided::setExtensions )
                , ( bp::arg("contextID"), bp::arg("extensions") )
                , " The setExtensions method allows users to override the extensions across graphics contexts.\n Typically used when you have different extensions supported across graphics pipes\n but need to ensure that they all use the same low common denominator extensions." );
        
        }
        { //::osg::StencilTwoSided::setFunction
        
            typedef void ( ::osg::StencilTwoSided::*setFunction_function_type)( ::osg::StencilTwoSided::Face,::osg::StencilTwoSided::Function,int,unsigned int ) ;
            
            StencilTwoSided_exposer.def( 
                "setFunction"
                , setFunction_function_type( &::osg::StencilTwoSided::setFunction )
                , ( bp::arg("face"), bp::arg("func"), bp::arg("ref"), bp::arg("mask") ) );
        
        }
        { //::osg::StencilTwoSided::setFunction
        
            typedef void ( ::osg::StencilTwoSided::*setFunction_function_type)( ::osg::StencilTwoSided::Face,::osg::StencilTwoSided::Function ) ;
            
            StencilTwoSided_exposer.def( 
                "setFunction"
                , setFunction_function_type( &::osg::StencilTwoSided::setFunction )
                , ( bp::arg("face"), bp::arg("func") ) );
        
        }
        { //::osg::StencilTwoSided::setFunctionMask
        
            typedef void ( ::osg::StencilTwoSided::*setFunctionMask_function_type)( ::osg::StencilTwoSided::Face,unsigned int ) ;
            
            StencilTwoSided_exposer.def( 
                "setFunctionMask"
                , setFunctionMask_function_type( &::osg::StencilTwoSided::setFunctionMask )
                , ( bp::arg("face"), bp::arg("mask") ) );
        
        }
        { //::osg::StencilTwoSided::setFunctionRef
        
            typedef void ( ::osg::StencilTwoSided::*setFunctionRef_function_type)( ::osg::StencilTwoSided::Face,int ) ;
            
            StencilTwoSided_exposer.def( 
                "setFunctionRef"
                , setFunctionRef_function_type( &::osg::StencilTwoSided::setFunctionRef )
                , ( bp::arg("face"), bp::arg("ref") ) );
        
        }
        { //::osg::StencilTwoSided::setOperation
        
            typedef void ( ::osg::StencilTwoSided::*setOperation_function_type)( ::osg::StencilTwoSided::Face,::osg::StencilTwoSided::Operation,::osg::StencilTwoSided::Operation,::osg::StencilTwoSided::Operation ) ;
            
            StencilTwoSided_exposer.def( 
                "setOperation"
                , setOperation_function_type( &::osg::StencilTwoSided::setOperation )
                , ( bp::arg("face"), bp::arg("sfail"), bp::arg("zfail"), bp::arg("zpass") )
                , " set the operations to apply when the various stencil and depth\n tests fail or pass.  First parameter is to control the operation\n when the stencil test fails.  The second parameter is to control the\n operation when the stencil test passes, but depth test fails. The\n third parameter controls the operation when both the stencil test\n and depth pass.  Ordering of parameter is the same as if using\n glStencilOp(,,)." );
        
        }
        { //::osg::StencilTwoSided::setStencilFailOperation
        
            typedef void ( ::osg::StencilTwoSided::*setStencilFailOperation_function_type)( ::osg::StencilTwoSided::Face,::osg::StencilTwoSided::Operation ) ;
            
            StencilTwoSided_exposer.def( 
                "setStencilFailOperation"
                , setStencilFailOperation_function_type( &::osg::StencilTwoSided::setStencilFailOperation )
                , ( bp::arg("face"), bp::arg("sfail") )
                , " set the operation when the stencil test fails." );
        
        }
        { //::osg::StencilTwoSided::setStencilPassAndDepthFailOperation
        
            typedef void ( ::osg::StencilTwoSided::*setStencilPassAndDepthFailOperation_function_type)( ::osg::StencilTwoSided::Face,::osg::StencilTwoSided::Operation ) ;
            
            StencilTwoSided_exposer.def( 
                "setStencilPassAndDepthFailOperation"
                , setStencilPassAndDepthFailOperation_function_type( &::osg::StencilTwoSided::setStencilPassAndDepthFailOperation )
                , ( bp::arg("face"), bp::arg("zfail") )
                , " set the operation when the stencil test passes but the depth test fails." );
        
        }
        { //::osg::StencilTwoSided::setStencilPassAndDepthPassOperation
        
            typedef void ( ::osg::StencilTwoSided::*setStencilPassAndDepthPassOperation_function_type)( ::osg::StencilTwoSided::Face,::osg::StencilTwoSided::Operation ) ;
            
            StencilTwoSided_exposer.def( 
                "setStencilPassAndDepthPassOperation"
                , setStencilPassAndDepthPassOperation_function_type( &::osg::StencilTwoSided::setStencilPassAndDepthPassOperation )
                , ( bp::arg("face"), bp::arg("zpass") )
                , " set the operation when both the stencil test and the depth test pass." );
        
        }
        { //::osg::StencilTwoSided::setWriteMask
        
            typedef void ( ::osg::StencilTwoSided::*setWriteMask_function_type)( ::osg::StencilTwoSided::Face,unsigned int ) ;
            
            StencilTwoSided_exposer.def( 
                "setWriteMask"
                , setWriteMask_function_type( &::osg::StencilTwoSided::setWriteMask )
                , ( bp::arg("face"), bp::arg("mask") ) );
        
        }
        { //::osg::StateAttribute::asTexture
        
            typedef ::osg::Texture * ( ::osg::StateAttribute::*asTexture_function_type)(  ) ;
            typedef ::osg::Texture * ( StencilTwoSided_wrapper::*default_asTexture_function_type)(  ) ;
            
            StencilTwoSided_exposer.def( 
                "asTexture"
                , asTexture_function_type(&::osg::StateAttribute::asTexture)
                , default_asTexture_function_type(&StencilTwoSided_wrapper::default_asTexture)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::StateAttribute::asTexture
        
            typedef ::osg::Texture const * ( ::osg::StateAttribute::*asTexture_function_type)(  ) const;
            typedef ::osg::Texture const * ( StencilTwoSided_wrapper::*default_asTexture_function_type)(  ) const;
            
            StencilTwoSided_exposer.def( 
                "asTexture"
                , asTexture_function_type(&::osg::StateAttribute::asTexture)
                , default_asTexture_function_type(&StencilTwoSided_wrapper::default_asTexture)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::StateAttribute::checkValidityOfAssociatedModes
        
            typedef bool ( ::osg::StateAttribute::*checkValidityOfAssociatedModes_function_type)( ::osg::State & ) const;
            typedef bool ( StencilTwoSided_wrapper::*default_checkValidityOfAssociatedModes_function_type)( ::osg::State & ) const;
            
            StencilTwoSided_exposer.def( 
                "checkValidityOfAssociatedModes"
                , checkValidityOfAssociatedModes_function_type(&::osg::StateAttribute::checkValidityOfAssociatedModes)
                , default_checkValidityOfAssociatedModes_function_type(&StencilTwoSided_wrapper::default_checkValidityOfAssociatedModes)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::StateAttribute::compileGLObjects
        
            typedef void ( ::osg::StateAttribute::*compileGLObjects_function_type)( ::osg::State & ) const;
            typedef void ( StencilTwoSided_wrapper::*default_compileGLObjects_function_type)( ::osg::State & ) const;
            
            StencilTwoSided_exposer.def( 
                "compileGLObjects"
                , compileGLObjects_function_type(&::osg::StateAttribute::compileGLObjects)
                , default_compileGLObjects_function_type(&StencilTwoSided_wrapper::default_compileGLObjects)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Object::computeDataVariance
        
            typedef void ( ::osg::Object::*computeDataVariance_function_type)(  ) ;
            typedef void ( StencilTwoSided_wrapper::*default_computeDataVariance_function_type)(  ) ;
            
            StencilTwoSided_exposer.def( 
                "computeDataVariance"
                , computeDataVariance_function_type(&::osg::Object::computeDataVariance)
                , default_computeDataVariance_function_type(&StencilTwoSided_wrapper::default_computeDataVariance) );
        
        }
        { //::osg::StateAttribute::getMember
        
            typedef unsigned int ( ::osg::StateAttribute::*getMember_function_type)(  ) const;
            typedef unsigned int ( StencilTwoSided_wrapper::*default_getMember_function_type)(  ) const;
            
            StencilTwoSided_exposer.def( 
                "getMember"
                , getMember_function_type(&::osg::StateAttribute::getMember)
                , default_getMember_function_type(&StencilTwoSided_wrapper::default_getMember) );
        
        }
        { //::osg::Object::getUserData
        
            typedef ::osg::Referenced * ( ::osg::Object::*getUserData_function_type)(  ) ;
            typedef ::osg::Referenced * ( StencilTwoSided_wrapper::*default_getUserData_function_type)(  ) ;
            
            StencilTwoSided_exposer.def( 
                "getUserData"
                , getUserData_function_type(&::osg::Object::getUserData)
                , default_getUserData_function_type(&StencilTwoSided_wrapper::default_getUserData)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Object::getUserData
        
            typedef ::osg::Referenced const * ( ::osg::Object::*getUserData_function_type)(  ) const;
            typedef ::osg::Referenced const * ( StencilTwoSided_wrapper::*default_getUserData_function_type)(  ) const;
            
            StencilTwoSided_exposer.def( 
                "getUserData"
                , getUserData_function_type(&::osg::Object::getUserData)
                , default_getUserData_function_type(&StencilTwoSided_wrapper::default_getUserData)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::StateAttribute::isTextureAttribute
        
            typedef bool ( ::osg::StateAttribute::*isTextureAttribute_function_type)(  ) const;
            typedef bool ( StencilTwoSided_wrapper::*default_isTextureAttribute_function_type)(  ) const;
            
            StencilTwoSided_exposer.def( 
                "isTextureAttribute"
                , isTextureAttribute_function_type(&::osg::StateAttribute::isTextureAttribute)
                , default_isTextureAttribute_function_type(&StencilTwoSided_wrapper::default_isTextureAttribute) );
        
        }
        { //::osg::StateAttribute::resizeGLObjectBuffers
        
            typedef void ( ::osg::StateAttribute::*resizeGLObjectBuffers_function_type)( unsigned int ) ;
            typedef void ( StencilTwoSided_wrapper::*default_resizeGLObjectBuffers_function_type)( unsigned int ) ;
            
            StencilTwoSided_exposer.def( 
                "resizeGLObjectBuffers"
                , resizeGLObjectBuffers_function_type(&::osg::StateAttribute::resizeGLObjectBuffers)
                , default_resizeGLObjectBuffers_function_type(&StencilTwoSided_wrapper::default_resizeGLObjectBuffers)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Object::setName
        
            typedef void ( ::osg::Object::*setName_function_type)( ::std::string const & ) ;
            typedef void ( StencilTwoSided_wrapper::*default_setName_function_type)( ::std::string const & ) ;
            
            StencilTwoSided_exposer.def( 
                "setName"
                , setName_function_type(&::osg::Object::setName)
                , default_setName_function_type(&StencilTwoSided_wrapper::default_setName)
                , ( bp::arg("name") ) );
        
        }
        { //::osg::Object::setName
        
            typedef void ( ::osg::Object::*setName_function_type)( char const * ) ;
            
            StencilTwoSided_exposer.def( 
                "setName"
                , setName_function_type( &::osg::Object::setName )
                , ( bp::arg("name") )
                , " Set the name of object using a C style string." );
        
        }
        { //::osg::Object::setThreadSafeRefUnref
        
            typedef void ( ::osg::Object::*setThreadSafeRefUnref_function_type)( bool ) ;
            typedef void ( StencilTwoSided_wrapper::*default_setThreadSafeRefUnref_function_type)( bool ) ;
            
            StencilTwoSided_exposer.def( 
                "setThreadSafeRefUnref"
                , setThreadSafeRefUnref_function_type(&::osg::Object::setThreadSafeRefUnref)
                , default_setThreadSafeRefUnref_function_type(&StencilTwoSided_wrapper::default_setThreadSafeRefUnref)
                , ( bp::arg("threadSafe") ) );
        
        }
        { //::osg::Object::setUserData
        
            typedef void ( ::osg::Object::*setUserData_function_type)( ::osg::Referenced * ) ;
            typedef void ( StencilTwoSided_wrapper::*default_setUserData_function_type)( ::osg::Referenced * ) ;
            
            StencilTwoSided_exposer.def( 
                "setUserData"
                , setUserData_function_type(&::osg::Object::setUserData)
                , default_setUserData_function_type(&StencilTwoSided_wrapper::default_setUserData)
                , ( bp::arg("obj") ) );
        
        }
        StencilTwoSided_exposer.staticmethod( "getExtensions" );
        StencilTwoSided_exposer.staticmethod( "setExtensions" );
    }

}
