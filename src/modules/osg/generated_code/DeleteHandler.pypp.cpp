// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "deletehandler.pypp.hpp"

namespace bp = boost::python;

struct DeleteHandler_wrapper : osg::DeleteHandler, bp::wrapper< osg::DeleteHandler > {

    DeleteHandler_wrapper(int numberOfFramesToRetainObjects=0 )
    : osg::DeleteHandler( numberOfFramesToRetainObjects )
      , bp::wrapper< osg::DeleteHandler >(){
        // constructor
    
    }

    virtual void flush(  ) {
        if( bp::override func_flush = this->get_override( "flush" ) )
            func_flush(  );
        else{
            this->osg::DeleteHandler::flush(  );
        }
    }
    
    void default_flush(  ) {
        osg::DeleteHandler::flush( );
    }

    virtual void flushAll(  ) {
        if( bp::override func_flushAll = this->get_override( "flushAll" ) )
            func_flushAll(  );
        else{
            this->osg::DeleteHandler::flushAll(  );
        }
    }
    
    void default_flushAll(  ) {
        osg::DeleteHandler::flushAll( );
    }

    virtual void requestDelete( ::osg::Referenced const * object ) {
        if( bp::override func_requestDelete = this->get_override( "requestDelete" ) )
            func_requestDelete( boost::python::ptr(object) );
        else{
            this->osg::DeleteHandler::requestDelete( boost::python::ptr(object) );
        }
    }
    
    void default_requestDelete( ::osg::Referenced const * object ) {
        osg::DeleteHandler::requestDelete( boost::python::ptr(object) );
    }

};

void register_DeleteHandler_class(){

    { //::osg::DeleteHandler
        typedef bp::class_< DeleteHandler_wrapper, boost::noncopyable > DeleteHandler_exposer_t;
        DeleteHandler_exposer_t DeleteHandler_exposer = DeleteHandler_exposer_t( "DeleteHandler", "\n Class for overriding the default delete behaviour so that users can implement their own object\n deletion schemes.\n This might be used to implement a protection scheme that avoids\n multiple threads deleting objects unintentionally.\n Note, the DeleteHandler cannot itself be reference counted, otherwise it\n would be responsible for deleting itself!\n A static auto_ptr<> is used internally in Referenced.cpp to manage the\n DeleteHandlers memory.\n", bp::init< bp::optional< int > >(( bp::arg("numberOfFramesToRetainObjects")=(int)(0) )) );
        bp::scope DeleteHandler_scope( DeleteHandler_exposer );
        bp::implicitly_convertible< int, osg::DeleteHandler >();
        { //::osg::DeleteHandler::doDelete
        
            typedef void ( ::osg::DeleteHandler::*doDelete_function_type)( ::osg::Referenced const * ) ;
            
            DeleteHandler_exposer.def( 
                "doDelete"
                , doDelete_function_type( &::osg::DeleteHandler::doDelete )
                , ( bp::arg("object") ) );
        
        }
        { //::osg::DeleteHandler::flush
        
            typedef void ( ::osg::DeleteHandler::*flush_function_type)(  ) ;
            typedef void ( DeleteHandler_wrapper::*default_flush_function_type)(  ) ;
            
            DeleteHandler_exposer.def( 
                "flush"
                , flush_function_type(&::osg::DeleteHandler::flush)
                , default_flush_function_type(&DeleteHandler_wrapper::default_flush) );
        
        }
        { //::osg::DeleteHandler::flushAll
        
            typedef void ( ::osg::DeleteHandler::*flushAll_function_type)(  ) ;
            typedef void ( DeleteHandler_wrapper::*default_flushAll_function_type)(  ) ;
            
            DeleteHandler_exposer.def( 
                "flushAll"
                , flushAll_function_type(&::osg::DeleteHandler::flushAll)
                , default_flushAll_function_type(&DeleteHandler_wrapper::default_flushAll) );
        
        }
        { //::osg::DeleteHandler::getFrameNumber
        
            typedef unsigned int ( ::osg::DeleteHandler::*getFrameNumber_function_type)(  ) const;
            
            DeleteHandler_exposer.def( 
                "getFrameNumber"
                , getFrameNumber_function_type( &::osg::DeleteHandler::getFrameNumber )
                , " Get the current frame number." );
        
        }
        { //::osg::DeleteHandler::getNumFramesToRetainObjects
        
            typedef unsigned int ( ::osg::DeleteHandler::*getNumFramesToRetainObjects_function_type)(  ) const;
            
            DeleteHandler_exposer.def( 
                "getNumFramesToRetainObjects"
                , getNumFramesToRetainObjects_function_type( &::osg::DeleteHandler::getNumFramesToRetainObjects ) );
        
        }
        { //::osg::DeleteHandler::requestDelete
        
            typedef void ( ::osg::DeleteHandler::*requestDelete_function_type)( ::osg::Referenced const * ) ;
            typedef void ( DeleteHandler_wrapper::*default_requestDelete_function_type)( ::osg::Referenced const * ) ;
            
            DeleteHandler_exposer.def( 
                "requestDelete"
                , requestDelete_function_type(&::osg::DeleteHandler::requestDelete)
                , default_requestDelete_function_type(&DeleteHandler_wrapper::default_requestDelete)
                , ( bp::arg("object") ) );
        
        }
        { //::osg::DeleteHandler::setFrameNumber
        
            typedef void ( ::osg::DeleteHandler::*setFrameNumber_function_type)( unsigned int ) ;
            
            DeleteHandler_exposer.def( 
                "setFrameNumber"
                , setFrameNumber_function_type( &::osg::DeleteHandler::setFrameNumber )
                , ( bp::arg("frameNumber") )
                , " Set the current frame number so that subsequent deletes get tagged as associated with this frame." );
        
        }
        { //::osg::DeleteHandler::setNumFramesToRetainObjects
        
            typedef void ( ::osg::DeleteHandler::*setNumFramesToRetainObjects_function_type)( unsigned int ) ;
            
            DeleteHandler_exposer.def( 
                "setNumFramesToRetainObjects"
                , setNumFramesToRetainObjects_function_type( &::osg::DeleteHandler::setNumFramesToRetainObjects )
                , ( bp::arg("numberOfFramesToRetainObjects") )
                , " Set the number of frames to retain objects that have been requested for deletion.\n When set to zero objects are deleted immediately, by setting to 1 they are kept around for an extra frame etc.\n The ability to retain objects for several frames is useful to prevent premature deletion when objects\n are still being used by graphics threads that use double buffering of rendering data structures with\n non ref_ptr<> pointers to scene graph elements." );
        
        }
    }

}
