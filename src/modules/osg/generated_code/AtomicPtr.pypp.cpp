// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "atomicptr.pypp.hpp"

namespace bp = boost::python;

void register_AtomicPtr_class(){

    { //::OpenThreads::AtomicPtr
        typedef bp::class_< OpenThreads::AtomicPtr, boost::noncopyable > AtomicPtr_exposer_t;
        AtomicPtr_exposer_t AtomicPtr_exposer = AtomicPtr_exposer_t( "AtomicPtr", "\n  Class: AtomicPtr\n   This class provides an atomic pointer assignment using cas operations.\n", bp::init< bp::optional< void * > >(( bp::arg("ptr")=bp::object() ), "\n  Class: AtomicPtr\n   This class provides an atomic pointer assignment using cas operations.\n") );
        bp::scope AtomicPtr_scope( AtomicPtr_exposer );
        bp::implicitly_convertible< void *, OpenThreads::AtomicPtr >();
        { //::OpenThreads::AtomicPtr::assign
        
            typedef bool ( ::OpenThreads::AtomicPtr::*assign_function_type)( void *,void const * const ) ;
            
            AtomicPtr_exposer.def( 
                "assign"
                , assign_function_type( &::OpenThreads::AtomicPtr::assign )
                , ( bp::arg("ptrNew"), bp::arg("ptrOld") ) );
        
        }
        { //::OpenThreads::AtomicPtr::get
        
            typedef void * ( ::OpenThreads::AtomicPtr::*get_function_type)(  ) const;
            
            AtomicPtr_exposer.def( 
                "get"
                , get_function_type( &::OpenThreads::AtomicPtr::get )
                , bp::return_value_policy< bp::return_opaque_pointer >() );
        
        }
    }

}
