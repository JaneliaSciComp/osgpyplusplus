// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "wrap_referenced.h"
#include "image.pypp.hpp"

namespace bp = boost::python;

struct Image_wrapper : osg::Image, bp::wrapper< osg::Image > {

    struct DimensionsChangedCallback_wrapper : osg::Image::DimensionsChangedCallback, bp::wrapper< osg::Image::DimensionsChangedCallback > {
    
        virtual void operator()( ::osg::Image * image ){
            bp::override func___call__ = this->get_override( "__call__" );
            func___call__( boost::python::ptr(image) );
        }
    
        virtual void setThreadSafeRefUnref( bool threadSafe ) {
            if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
                func_setThreadSafeRefUnref( threadSafe );
            else{
                this->osg::Referenced::setThreadSafeRefUnref( threadSafe );
            }
        }
        
        void default_setThreadSafeRefUnref( bool threadSafe ) {
            osg::Referenced::setThreadSafeRefUnref( threadSafe );
        }
    
    };

    struct UpdateCallback_wrapper : osg::Image::UpdateCallback, bp::wrapper< osg::Image::UpdateCallback > {
    
        UpdateCallback_wrapper()
        : osg::Image::UpdateCallback()
          , bp::wrapper< osg::Image::UpdateCallback >(){
            // null constructor
            
        }
    
        virtual void operator()( ::osg::StateAttribute * attr, ::osg::NodeVisitor * nv ) {
            if( bp::override func___call__ = this->get_override( "__call__" ) )
                func___call__( boost::python::ptr(attr), boost::python::ptr(nv) );
            else{
                this->osg::Image::UpdateCallback::operator()( boost::python::ptr(attr), boost::python::ptr(nv) );
            }
        }
        
        void default___call__( ::osg::StateAttribute * attr, ::osg::NodeVisitor * nv ) {
            osg::Image::UpdateCallback::operator()( boost::python::ptr(attr), boost::python::ptr(nv) );
        }
    
        virtual void computeDataVariance(  ) {
            if( bp::override func_computeDataVariance = this->get_override( "computeDataVariance" ) )
                func_computeDataVariance(  );
            else{
                this->osg::Object::computeDataVariance(  );
            }
        }
        
        void default_computeDataVariance(  ) {
            osg::Object::computeDataVariance( );
        }
    
        virtual ::osg::Referenced * getUserData(  ) {
            if( bp::override func_getUserData = this->get_override( "getUserData" ) )
                return func_getUserData(  );
            else{
                return this->osg::Object::getUserData(  );
            }
        }
        
        ::osg::Referenced * default_getUserData(  ) {
            return osg::Object::getUserData( );
        }
    
        virtual ::osg::Referenced const * getUserData(  ) const  {
            if( bp::override func_getUserData = this->get_override( "getUserData" ) )
                return func_getUserData(  );
            else{
                return this->osg::Object::getUserData(  );
            }
        }
        
        ::osg::Referenced const * default_getUserData(  ) const  {
            return osg::Object::getUserData( );
        }
    
        virtual void resizeGLObjectBuffers( unsigned int arg0 ) {
            if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
                func_resizeGLObjectBuffers( arg0 );
            else{
                this->osg::Object::resizeGLObjectBuffers( arg0 );
            }
        }
        
        void default_resizeGLObjectBuffers( unsigned int arg0 ) {
            osg::Object::resizeGLObjectBuffers( arg0 );
        }
    
        virtual void setName( ::std::string const & name ) {
            if( bp::override func_setName = this->get_override( "setName" ) )
                func_setName( name );
            else{
                this->osg::Object::setName( name );
            }
        }
        
        void default_setName( ::std::string const & name ) {
            osg::Object::setName( name );
        }
    
        virtual void setThreadSafeRefUnref( bool threadSafe ) {
            if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
                func_setThreadSafeRefUnref( threadSafe );
            else{
                this->osg::Object::setThreadSafeRefUnref( threadSafe );
            }
        }
        
        void default_setThreadSafeRefUnref( bool threadSafe ) {
            osg::Object::setThreadSafeRefUnref( threadSafe );
        }
    
        virtual void setUserData( ::osg::Referenced * obj ) {
            if( bp::override func_setUserData = this->get_override( "setUserData" ) )
                func_setUserData( boost::python::ptr(obj) );
            else{
                this->osg::Object::setUserData( boost::python::ptr(obj) );
            }
        }
        
        void default_setUserData( ::osg::Referenced * obj ) {
            osg::Object::setUserData( boost::python::ptr(obj) );
        }
    
    };

    Image_wrapper( )
    : osg::Image( )
      , bp::wrapper< osg::Image >(){
        // null constructor
    
    }

    virtual void allocateImage( int s, int t, int r, ::GLenum pixelFormat, ::GLenum type, int packing=1 ) {
        if( bp::override func_allocateImage = this->get_override( "allocateImage" ) )
            func_allocateImage( s, t, r, pixelFormat, type, packing );
        else{
            this->osg::Image::allocateImage( s, t, r, pixelFormat, type, packing );
        }
    }
    
    void default_allocateImage( int s, int t, int r, ::GLenum pixelFormat, ::GLenum type, int packing=1 ) {
        osg::Image::allocateImage( s, t, r, pixelFormat, type, packing );
    }

    virtual ::osg::Image * asImage(  ) {
        if( bp::override func_asImage = this->get_override( "asImage" ) )
            return func_asImage(  );
        else{
            return this->osg::Image::asImage(  );
        }
    }
    
    ::osg::Image * default_asImage(  ) {
        return osg::Image::asImage( );
    }

    virtual ::osg::Image const * asImage(  ) const  {
        if( bp::override func_asImage = this->get_override( "asImage" ) )
            return func_asImage(  );
        else{
            return this->osg::Image::asImage(  );
        }
    }
    
    ::osg::Image const * default_asImage(  ) const  {
        return osg::Image::asImage( );
    }

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osg::Image::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osg::Image::className( );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone( boost::ref(copyop) );
        else{
            return this->osg::Image::clone( boost::ref(copyop) );
        }
    }
    
    ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
        return osg::Image::clone( boost::ref(copyop) );
    }

    virtual ::osg::Object * cloneType(  ) const  {
        if( bp::override func_cloneType = this->get_override( "cloneType" ) )
            return func_cloneType(  );
        else{
            return this->osg::Image::cloneType(  );
        }
    }
    
    ::osg::Object * default_cloneType(  ) const  {
        return osg::Image::cloneType( );
    }

    virtual void copySubImage( int s_offset, int t_offset, int r_offset, ::osg::Image const * source ) {
        if( bp::override func_copySubImage = this->get_override( "copySubImage" ) )
            func_copySubImage( s_offset, t_offset, r_offset, boost::python::ptr(source) );
        else{
            this->osg::Image::copySubImage( s_offset, t_offset, r_offset, boost::python::ptr(source) );
        }
    }
    
    void default_copySubImage( int s_offset, int t_offset, int r_offset, ::osg::Image const * source ) {
        osg::Image::copySubImage( s_offset, t_offset, r_offset, boost::python::ptr(source) );
    }

    virtual ::GLvoid const * getDataPointer(  ) const  {
        if( bp::override func_getDataPointer = this->get_override( "getDataPointer" ) )
            return func_getDataPointer(  );
        else{
            return this->osg::Image::getDataPointer(  );
        }
    }
    
    ::GLvoid const * default_getDataPointer(  ) const  {
        return osg::Image::getDataPointer( );
    }

    virtual unsigned int getTotalDataSize(  ) const  {
        if( bp::override func_getTotalDataSize = this->get_override( "getTotalDataSize" ) )
            return func_getTotalDataSize(  );
        else{
            return this->osg::Image::getTotalDataSize(  );
        }
    }
    
    unsigned int default_getTotalDataSize(  ) const  {
        return osg::Image::getTotalDataSize( );
    }

    virtual bool isImageTranslucent(  ) const  {
        if( bp::override func_isImageTranslucent = this->get_override( "isImageTranslucent" ) )
            return func_isImageTranslucent(  );
        else{
            return this->osg::Image::isImageTranslucent(  );
        }
    }
    
    bool default_isImageTranslucent(  ) const  {
        return osg::Image::isImageTranslucent( );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osg::Image::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osg::Image::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osg::Image::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osg::Image::libraryName( );
    }

    virtual void readImageFromCurrentTexture( unsigned int contextID, bool copyMipMapsIfAvailable, ::GLenum type=5121, unsigned int face=0 ) {
        if( bp::override func_readImageFromCurrentTexture = this->get_override( "readImageFromCurrentTexture" ) )
            func_readImageFromCurrentTexture( contextID, copyMipMapsIfAvailable, type, face );
        else{
            this->osg::Image::readImageFromCurrentTexture( contextID, copyMipMapsIfAvailable, type, face );
        }
    }
    
    void default_readImageFromCurrentTexture( unsigned int contextID, bool copyMipMapsIfAvailable, ::GLenum type=5121, unsigned int face=0 ) {
        osg::Image::readImageFromCurrentTexture( contextID, copyMipMapsIfAvailable, type, face );
    }

    virtual void readPixels( int x, int y, int width, int height, ::GLenum pixelFormat, ::GLenum type, int packing=1 ) {
        if( bp::override func_readPixels = this->get_override( "readPixels" ) )
            func_readPixels( x, y, width, height, pixelFormat, type, packing );
        else{
            this->osg::Image::readPixels( x, y, width, height, pixelFormat, type, packing );
        }
    }
    
    void default_readPixels( int x, int y, int width, int height, ::GLenum pixelFormat, ::GLenum type, int packing=1 ) {
        osg::Image::readPixels( x, y, width, height, pixelFormat, type, packing );
    }

    virtual bool requiresUpdateCall(  ) const  {
        if( bp::override func_requiresUpdateCall = this->get_override( "requiresUpdateCall" ) )
            return func_requiresUpdateCall(  );
        else{
            return this->osg::Image::requiresUpdateCall(  );
        }
    }
    
    bool default_requiresUpdateCall(  ) const  {
        return osg::Image::requiresUpdateCall( );
    }

    virtual void scaleImage( int s, int t, int r, ::GLenum newDataType ) {
        if( bp::override func_scaleImage = this->get_override( "scaleImage" ) )
            func_scaleImage( s, t, r, newDataType );
        else{
            this->osg::Image::scaleImage( s, t, r, newDataType );
        }
    }
    
    void default_scaleImage( int s, int t, int r, ::GLenum newDataType ) {
        osg::Image::scaleImage( s, t, r, newDataType );
    }

    virtual bool sendFocusHint( bool arg0 ) {
        if( bp::override func_sendFocusHint = this->get_override( "sendFocusHint" ) )
            return func_sendFocusHint( arg0 );
        else{
            return this->osg::Image::sendFocusHint( arg0 );
        }
    }
    
    bool default_sendFocusHint( bool arg0 ) {
        return osg::Image::sendFocusHint( arg0 );
    }

    virtual bool sendKeyEvent( int arg0, bool arg1 ) {
        if( bp::override func_sendKeyEvent = this->get_override( "sendKeyEvent" ) )
            return func_sendKeyEvent( arg0, arg1 );
        else{
            return this->osg::Image::sendKeyEvent( arg0, arg1 );
        }
    }
    
    bool default_sendKeyEvent( int arg0, bool arg1 ) {
        return osg::Image::sendKeyEvent( arg0, arg1 );
    }

    virtual bool sendPointerEvent( int arg0, int arg1, int arg2 ) {
        if( bp::override func_sendPointerEvent = this->get_override( "sendPointerEvent" ) )
            return func_sendPointerEvent( arg0, arg1, arg2 );
        else{
            return this->osg::Image::sendPointerEvent( arg0, arg1, arg2 );
        }
    }
    
    bool default_sendPointerEvent( int arg0, int arg1, int arg2 ) {
        return osg::Image::sendPointerEvent( arg0, arg1, arg2 );
    }

    virtual void setFrameLastRendered( ::osg::FrameStamp const * arg0 ) {
        if( bp::override func_setFrameLastRendered = this->get_override( "setFrameLastRendered" ) )
            func_setFrameLastRendered( boost::python::ptr(arg0) );
        else{
            this->osg::Image::setFrameLastRendered( boost::python::ptr(arg0) );
        }
    }
    
    void default_setFrameLastRendered( ::osg::FrameStamp const * arg0 ) {
        osg::Image::setFrameLastRendered( boost::python::ptr(arg0) );
    }

    virtual void setImage( int s, int t, int r, ::GLint internalTextureformat, ::GLenum pixelFormat, ::GLenum type, unsigned char * data, ::osg::Image::AllocationMode mode, int packing=1, int rowLength=0 ) {
        if( bp::override func_setImage = this->get_override( "setImage" ) )
            func_setImage( s, t, r, internalTextureformat, pixelFormat, type, data, mode, packing, rowLength );
        else{
            this->osg::Image::setImage( s, t, r, internalTextureformat, pixelFormat, type, data, mode, packing, rowLength );
        }
    }
    
    void default_setImage( int s, int t, int r, ::GLint internalTextureformat, ::GLenum pixelFormat, ::GLenum type, unsigned char * data, ::osg::Image::AllocationMode mode, int packing=1, int rowLength=0 ) {
        osg::Image::setImage( s, t, r, internalTextureformat, pixelFormat, type, data, mode, packing, rowLength );
    }

    virtual void update( ::osg::NodeVisitor * arg0 ) {
        if( bp::override func_update = this->get_override( "update" ) )
            func_update( boost::python::ptr(arg0) );
        else{
            this->osg::Image::update( boost::python::ptr(arg0) );
        }
    }
    
    void default_update( ::osg::NodeVisitor * arg0 ) {
        osg::Image::update( boost::python::ptr(arg0) );
    }

    virtual ::osg::Array * asArray(  ) {
        if( bp::override func_asArray = this->get_override( "asArray" ) )
            return func_asArray(  );
        else{
            return this->osg::BufferData::asArray(  );
        }
    }
    
    ::osg::Array * default_asArray(  ) {
        return osg::BufferData::asArray( );
    }

    virtual ::osg::Array const * asArray(  ) const  {
        if( bp::override func_asArray = this->get_override( "asArray" ) )
            return func_asArray(  );
        else{
            return this->osg::BufferData::asArray(  );
        }
    }
    
    ::osg::Array const * default_asArray(  ) const  {
        return osg::BufferData::asArray( );
    }

    virtual void computeDataVariance(  ) {
        if( bp::override func_computeDataVariance = this->get_override( "computeDataVariance" ) )
            func_computeDataVariance(  );
        else{
            this->osg::Object::computeDataVariance(  );
        }
    }
    
    void default_computeDataVariance(  ) {
        osg::Object::computeDataVariance( );
    }

    virtual ::osg::Referenced * getUserData(  ) {
        if( bp::override func_getUserData = this->get_override( "getUserData" ) )
            return func_getUserData(  );
        else{
            return this->osg::Object::getUserData(  );
        }
    }
    
    ::osg::Referenced * default_getUserData(  ) {
        return osg::Object::getUserData( );
    }

    virtual ::osg::Referenced const * getUserData(  ) const  {
        if( bp::override func_getUserData = this->get_override( "getUserData" ) )
            return func_getUserData(  );
        else{
            return this->osg::Object::getUserData(  );
        }
    }
    
    ::osg::Referenced const * default_getUserData(  ) const  {
        return osg::Object::getUserData( );
    }

    virtual void resizeGLObjectBuffers( unsigned int maxSize ) {
        if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
            func_resizeGLObjectBuffers( maxSize );
        else{
            this->osg::BufferData::resizeGLObjectBuffers( maxSize );
        }
    }
    
    void default_resizeGLObjectBuffers( unsigned int maxSize ) {
        osg::BufferData::resizeGLObjectBuffers( maxSize );
    }

    virtual void setName( ::std::string const & name ) {
        if( bp::override func_setName = this->get_override( "setName" ) )
            func_setName( name );
        else{
            this->osg::Object::setName( name );
        }
    }
    
    void default_setName( ::std::string const & name ) {
        osg::Object::setName( name );
    }

    virtual void setThreadSafeRefUnref( bool threadSafe ) {
        if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
            func_setThreadSafeRefUnref( threadSafe );
        else{
            this->osg::Object::setThreadSafeRefUnref( threadSafe );
        }
    }
    
    void default_setThreadSafeRefUnref( bool threadSafe ) {
        osg::Object::setThreadSafeRefUnref( threadSafe );
    }

    virtual void setUserData( ::osg::Referenced * obj ) {
        if( bp::override func_setUserData = this->get_override( "setUserData" ) )
            func_setUserData( boost::python::ptr(obj) );
        else{
            this->osg::Object::setUserData( boost::python::ptr(obj) );
        }
    }
    
    void default_setUserData( ::osg::Referenced * obj ) {
        osg::Object::setUserData( boost::python::ptr(obj) );
    }

};

static void wrap_increment_DataIterator(osg::Image::DataIterator& val) {++val;}

void register_Image_class(){

    { //::osg::Image
        typedef bp::class_< Image_wrapper, bp::bases< osg::BufferData >, osg::ref_ptr< Image_wrapper >, boost::noncopyable > Image_exposer_t;
        Image_exposer_t Image_exposer = Image_exposer_t( "Image", "\n Image class for encapsulating the storage texture image data.\n", bp::no_init );
        bp::scope Image_scope( Image_exposer );
        bp::enum_< osg::Image::AllocationMode>("AllocationMode")
            .value("NO_DELETE", osg::Image::NO_DELETE)
            .value("USE_NEW_DELETE", osg::Image::USE_NEW_DELETE)
            .value("USE_MALLOC_FREE", osg::Image::USE_MALLOC_FREE)
            .export_values()
            ;
        bp::enum_< osg::Image::Origin>("Origin")
            .value("BOTTOM_LEFT", osg::Image::BOTTOM_LEFT)
            .value("TOP_LEFT", osg::Image::TOP_LEFT)
            .export_values()
            ;
        bp::enum_< osg::Image::WriteHint>("WriteHint")
            .value("NO_PREFERENCE", osg::Image::NO_PREFERENCE)
            .value("STORE_INLINE", osg::Image::STORE_INLINE)
            .value("EXTERNAL_FILE", osg::Image::EXTERNAL_FILE)
            .export_values()
            ;
        { //::osg::Image::DataIterator
            typedef bp::class_< osg::Image::DataIterator > DataIterator_exposer_t;
            DataIterator_exposer_t DataIterator_exposer = DataIterator_exposer_t( "DataIterator", " Convenience class for assisting the copying of image data when the image data isnt contiguous.", bp::init< osg::Image const * >(( bp::arg("image") ), " Convenience class for assisting the copying of image data when the image data isnt contiguous.") );
            bp::scope DataIterator_scope( DataIterator_exposer );
            bp::implicitly_convertible< osg::Image const *, osg::Image::DataIterator >();
            DataIterator_exposer.def( bp::init< osg::Image::DataIterator const & >(( bp::arg("ri") )) );
            { //::osg::Image::DataIterator::size
            
                typedef unsigned int ( ::osg::Image::DataIterator::*size_function_type)(  ) const;
                
                DataIterator_exposer.def( 
                    "size"
                    , size_function_type( &::osg::Image::DataIterator::size )
                    , " Size of current block to copy." );
            
            }
            { //::osg::Image::DataIterator::valid
            
                typedef bool ( ::osg::Image::DataIterator::*valid_function_type)(  ) const;
                
                DataIterator_exposer.def( 
                    "valid"
                    , valid_function_type( &::osg::Image::DataIterator::valid )
                    , " is iterator valid." );
            
            }
            DataIterator_exposer.def("increment", &wrap_increment_DataIterator);
        }
        bp::class_< Image_wrapper::DimensionsChangedCallback_wrapper, bp::bases< osg::Referenced >, osg::ref_ptr< Image_wrapper::DimensionsChangedCallback_wrapper >, boost::noncopyable >( "DimensionsChangedCallback", "\n Pass frame information to the custom Image classes, to be called only when objects associated with imagery are not culled.\n", bp::no_init )    
            .def( 
                "__call__"
                , bp::pure_virtual( (void ( ::osg::Image::DimensionsChangedCallback::* )( ::osg::Image * ))(&::osg::Image::DimensionsChangedCallback::operator()) )
                , ( bp::arg("image") )
                , "\n Pass frame information to the custom Image classes, to be called only when objects associated with imagery are not culled.\n" )    
            .def( 
                "setThreadSafeRefUnref"
                , (void ( ::osg::Referenced::* )( bool ))(&::osg::Referenced::setThreadSafeRefUnref)
                , (void ( Image_wrapper::DimensionsChangedCallback_wrapper::* )( bool ))(&Image_wrapper::DimensionsChangedCallback_wrapper::default_setThreadSafeRefUnref)
                , ( bp::arg("threadSafe") ) );
        bp::class_< Image_wrapper::UpdateCallback_wrapper, osg::ref_ptr< Image_wrapper::UpdateCallback_wrapper >, boost::noncopyable >( "UpdateCallback", "\n Convenience update callback class that can be attached to a StateAttribute (such as Textures) to ensure\n that the Image::update(NodeVisitor*) method is called during the update traversal.  This callback\n is automatically attached when Image::requiresUpdateCall() is true (its false by default.)\n" )    
            .def( 
                "__call__"
                , (void ( ::osg::Image::UpdateCallback::* )( ::osg::StateAttribute *,::osg::NodeVisitor * ))(&::osg::Image::UpdateCallback::operator())
                , (void ( Image_wrapper::UpdateCallback_wrapper::* )( ::osg::StateAttribute *,::osg::NodeVisitor * ))(&Image_wrapper::UpdateCallback_wrapper::default___call__)
                , ( bp::arg("attr"), bp::arg("nv") ) )    
            .def( 
                "computeDataVariance"
                , (void ( ::osg::Object::* )(  ))(&::osg::Object::computeDataVariance)
                , (void ( Image_wrapper::UpdateCallback_wrapper::* )(  ))(&Image_wrapper::UpdateCallback_wrapper::default_computeDataVariance) )    
            .def( 
                "getUserData"
                , (::osg::Referenced * ( ::osg::Object::* )(  ))(&::osg::Object::getUserData)
                , (::osg::Referenced * ( Image_wrapper::UpdateCallback_wrapper::* )(  ))(&Image_wrapper::UpdateCallback_wrapper::default_getUserData)
                , bp::return_internal_reference< >() )    
            .def( 
                "getUserData"
                , (::osg::Referenced const * ( ::osg::Object::* )(  )const)(&::osg::Object::getUserData)
                , (::osg::Referenced const * ( Image_wrapper::UpdateCallback_wrapper::* )(  )const)(&Image_wrapper::UpdateCallback_wrapper::default_getUserData)
                , bp::return_internal_reference< >() )    
            .def( 
                "resizeGLObjectBuffers"
                , (void ( ::osg::Object::* )( unsigned int ))(&::osg::Object::resizeGLObjectBuffers)
                , (void ( Image_wrapper::UpdateCallback_wrapper::* )( unsigned int ))(&Image_wrapper::UpdateCallback_wrapper::default_resizeGLObjectBuffers)
                , ( bp::arg("arg0") ) )    
            .def( 
                "setName"
                , (void ( ::osg::Object::* )( ::std::string const & ))(&::osg::Object::setName)
                , (void ( Image_wrapper::UpdateCallback_wrapper::* )( ::std::string const & ))(&Image_wrapper::UpdateCallback_wrapper::default_setName)
                , ( bp::arg("name") ) )    
            .def( 
                "setName"
                , (void ( ::osg::Object::* )( char const * ))( &::osg::Object::setName )
                , ( bp::arg("name") )
                , " Set the name of object using a C style string." )    
            .def( 
                "setThreadSafeRefUnref"
                , (void ( ::osg::Object::* )( bool ))(&::osg::Object::setThreadSafeRefUnref)
                , (void ( Image_wrapper::UpdateCallback_wrapper::* )( bool ))(&Image_wrapper::UpdateCallback_wrapper::default_setThreadSafeRefUnref)
                , ( bp::arg("threadSafe") ) )    
            .def( 
                "setUserData"
                , (void ( ::osg::Object::* )( ::osg::Referenced * ))(&::osg::Object::setUserData)
                , (void ( Image_wrapper::UpdateCallback_wrapper::* )( ::osg::Referenced * ))(&Image_wrapper::UpdateCallback_wrapper::default_setUserData)
                , ( bp::arg("obj") ) );
        Image_exposer.def( bp::init< >("\n Image class for encapsulating the storage texture image data.\n") );
        { //::osg::Image::addDimensionsChangedCallback
        
            typedef void ( ::osg::Image::*addDimensionsChangedCallback_function_type)( ::osg::Image::DimensionsChangedCallback * ) ;
            
            Image_exposer.def( 
                "addDimensionsChangedCallback"
                , addDimensionsChangedCallback_function_type( &::osg::Image::addDimensionsChangedCallback )
                , ( bp::arg("cb") ) );
        
        }
        { //::osg::Image::allocateImage
        
            typedef void ( ::osg::Image::*allocateImage_function_type)( int,int,int,::GLenum,::GLenum,int ) ;
            typedef void ( Image_wrapper::*default_allocateImage_function_type)( int,int,int,::GLenum,::GLenum,int ) ;
            
            Image_exposer.def( 
                "allocateImage"
                , allocateImage_function_type(&::osg::Image::allocateImage)
                , default_allocateImage_function_type(&Image_wrapper::default_allocateImage)
                , ( bp::arg("s"), bp::arg("t"), bp::arg("r"), bp::arg("pixelFormat"), bp::arg("type"), bp::arg("packing")=(int)(1) ) );
        
        }
        { //::osg::Image::asImage
        
            typedef ::osg::Image * ( ::osg::Image::*asImage_function_type)(  ) ;
            typedef ::osg::Image * ( Image_wrapper::*default_asImage_function_type)(  ) ;
            
            Image_exposer.def( 
                "asImage"
                , asImage_function_type(&::osg::Image::asImage)
                , default_asImage_function_type(&Image_wrapper::default_asImage)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Image::asImage
        
            typedef ::osg::Image const * ( ::osg::Image::*asImage_function_type)(  ) const;
            typedef ::osg::Image const * ( Image_wrapper::*default_asImage_function_type)(  ) const;
            
            Image_exposer.def( 
                "asImage"
                , asImage_function_type(&::osg::Image::asImage)
                , default_asImage_function_type(&Image_wrapper::default_asImage)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Image::className
        
            typedef char const * ( ::osg::Image::*className_function_type)(  ) const;
            typedef char const * ( Image_wrapper::*default_className_function_type)(  ) const;
            
            Image_exposer.def( 
                "className"
                , className_function_type(&::osg::Image::className)
                , default_className_function_type(&Image_wrapper::default_className) );
        
        }
        { //::osg::Image::clone
        
            typedef ::osg::Object * ( ::osg::Image::*clone_function_type)( ::osg::CopyOp const & ) const;
            typedef ::osg::Object * ( Image_wrapper::*default_clone_function_type)( ::osg::CopyOp const & ) const;
            
            Image_exposer.def( 
                "clone"
                , clone_function_type(&::osg::Image::clone)
                , default_clone_function_type(&Image_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::Image::cloneType
        
            typedef ::osg::Object * ( ::osg::Image::*cloneType_function_type)(  ) const;
            typedef ::osg::Object * ( Image_wrapper::*default_cloneType_function_type)(  ) const;
            
            Image_exposer.def( 
                "cloneType"
                , cloneType_function_type(&::osg::Image::cloneType)
                , default_cloneType_function_type(&Image_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::Image::computeBlockSize
        
            typedef unsigned int ( *computeBlockSize_function_type )( ::GLenum,::GLenum );
            
            Image_exposer.def( 
                "computeBlockSize"
                , computeBlockSize_function_type( &::osg::Image::computeBlockSize )
                , ( bp::arg("pixelFormat"), bp::arg("packing") ) );
        
        }
        { //::osg::Image::computeFormatDataType
        
            typedef ::GLenum ( *computeFormatDataType_function_type )( ::GLenum );
            
            Image_exposer.def( 
                "computeFormatDataType"
                , computeFormatDataType_function_type( &::osg::Image::computeFormatDataType )
                , ( bp::arg("pixelFormat") ) );
        
        }
        { //::osg::Image::computeImageSizeInBytes
        
            typedef unsigned int ( *computeImageSizeInBytes_function_type )( int,int,int,::GLenum,::GLenum,int,int,int );
            
            Image_exposer.def( 
                "computeImageSizeInBytes"
                , computeImageSizeInBytes_function_type( &::osg::Image::computeImageSizeInBytes )
                , ( bp::arg("width"), bp::arg("height"), bp::arg("depth"), bp::arg("pixelFormat"), bp::arg("type"), bp::arg("packing")=(int)(1), bp::arg("slice_packing")=(int)(1), bp::arg("image_packing")=(int)(1) ) );
        
        }
        { //::osg::Image::computeNearestPowerOfTwo
        
            typedef int ( *computeNearestPowerOfTwo_function_type )( int,float );
            
            Image_exposer.def( 
                "computeNearestPowerOfTwo"
                , computeNearestPowerOfTwo_function_type( &::osg::Image::computeNearestPowerOfTwo )
                , ( bp::arg("s"), bp::arg("bias")=5.0e-1f ) );
        
        }
        { //::osg::Image::computeNumComponents
        
            typedef unsigned int ( *computeNumComponents_function_type )( ::GLenum );
            
            Image_exposer.def( 
                "computeNumComponents"
                , computeNumComponents_function_type( &::osg::Image::computeNumComponents )
                , ( bp::arg("pixelFormat") ) );
        
        }
        { //::osg::Image::computeNumberOfMipmapLevels
        
            typedef int ( *computeNumberOfMipmapLevels_function_type )( int,int,int );
            
            Image_exposer.def( 
                "computeNumberOfMipmapLevels"
                , computeNumberOfMipmapLevels_function_type( &::osg::Image::computeNumberOfMipmapLevels )
                , ( bp::arg("s"), bp::arg("t")=(int)(1), bp::arg("r")=(int)(1) ) );
        
        }
        { //::osg::Image::computePixelFormat
        
            typedef ::GLenum ( *computePixelFormat_function_type )( ::GLenum );
            
            Image_exposer.def( 
                "computePixelFormat"
                , computePixelFormat_function_type( &::osg::Image::computePixelFormat )
                , ( bp::arg("pixelFormat") ) );
        
        }
        { //::osg::Image::computePixelSizeInBits
        
            typedef unsigned int ( *computePixelSizeInBits_function_type )( ::GLenum,::GLenum );
            
            Image_exposer.def( 
                "computePixelSizeInBits"
                , computePixelSizeInBits_function_type( &::osg::Image::computePixelSizeInBits )
                , ( bp::arg("pixelFormat"), bp::arg("type") ) );
        
        }
        { //::osg::Image::computeRowWidthInBytes
        
            typedef unsigned int ( *computeRowWidthInBytes_function_type )( int,::GLenum,::GLenum,int );
            
            Image_exposer.def( 
                "computeRowWidthInBytes"
                , computeRowWidthInBytes_function_type( &::osg::Image::computeRowWidthInBytes )
                , ( bp::arg("width"), bp::arg("pixelFormat"), bp::arg("type"), bp::arg("packing") ) );
        
        }
        { //::osg::Image::copySubImage
        
            typedef void ( ::osg::Image::*copySubImage_function_type)( int,int,int,::osg::Image const * ) ;
            typedef void ( Image_wrapper::*default_copySubImage_function_type)( int,int,int,::osg::Image const * ) ;
            
            Image_exposer.def( 
                "copySubImage"
                , copySubImage_function_type(&::osg::Image::copySubImage)
                , default_copySubImage_function_type(&Image_wrapper::default_copySubImage)
                , ( bp::arg("s_offset"), bp::arg("t_offset"), bp::arg("r_offset"), bp::arg("source") ) );
        
        }
        { //::osg::Image::ensureValidSizeForTexturing
        
            typedef void ( ::osg::Image::*ensureValidSizeForTexturing_function_type)( ::GLint ) ;
            
            Image_exposer.def( 
                "ensureValidSizeForTexturing"
                , ensureValidSizeForTexturing_function_type( &::osg::Image::ensureValidSizeForTexturing )
                , ( bp::arg("maxTextureSize") )
                , " Ensure image dimensions are a power of two.\n Mipmapped textures require the image dimensions to be\n power of two and are within the maxiumum texture size for\n the host machine." );
        
        }
        { //::osg::Image::flipDepth
        
            typedef void ( ::osg::Image::*flipDepth_function_type)(  ) ;
            
            Image_exposer.def( 
                "flipDepth"
                , flipDepth_function_type( &::osg::Image::flipDepth )
                , " Flip the image around the r dimension. Only relevent for 3D textures." );
        
        }
        { //::osg::Image::flipHorizontal
        
            typedef void ( ::osg::Image::*flipHorizontal_function_type)(  ) ;
            
            Image_exposer.def( 
                "flipHorizontal"
                , flipHorizontal_function_type( &::osg::Image::flipHorizontal )
                , " Flip the image horizontally, around s dimension." );
        
        }
        { //::osg::Image::flipVertical
        
            typedef void ( ::osg::Image::*flipVertical_function_type)(  ) ;
            
            Image_exposer.def( 
                "flipVertical"
                , flipVertical_function_type( &::osg::Image::flipVertical )
                , " Flip the image vertically, around t dimension." );
        
        }
        { //::osg::Image::getAllocationMode
        
            typedef ::osg::Image::AllocationMode ( ::osg::Image::*getAllocationMode_function_type)(  ) const;
            
            Image_exposer.def( 
                "getAllocationMode"
                , getAllocationMode_function_type( &::osg::Image::getAllocationMode )
                , " Get the method used for deleting data once it goes out of scope." );
        
        }
        { //::osg::Image::getColor
        
            typedef ::osg::Vec4 ( ::osg::Image::*getColor_function_type)( unsigned int,unsigned int,unsigned int ) const;
            
            Image_exposer.def( 
                "getColor"
                , getColor_function_type( &::osg::Image::getColor )
                , ( bp::arg("s"), bp::arg("t")=(unsigned int)(0), bp::arg("r")=(unsigned int)(0) )
                , " Get the color value for specified texcoord." );
        
        }
        { //::osg::Image::getColor
        
            typedef ::osg::Vec4 ( ::osg::Image::*getColor_function_type)( ::osg::Vec2 const & ) const;
            
            Image_exposer.def( 
                "getColor"
                , getColor_function_type( &::osg::Image::getColor )
                , ( bp::arg("texcoord") )
                , " Get the color value for specified texcoord." );
        
        }
        { //::osg::Image::getColor
        
            typedef ::osg::Vec4 ( ::osg::Image::*getColor_function_type)( ::osg::Vec3 const & ) const;
            
            Image_exposer.def( 
                "getColor"
                , getColor_function_type( &::osg::Image::getColor )
                , ( bp::arg("texcoord") )
                , " Get the color value for specified texcoord." );
        
        }
        { //::osg::Image::getDataPointer
        
            typedef ::GLvoid const * ( ::osg::Image::*getDataPointer_function_type)(  ) const;
            typedef ::GLvoid const * ( Image_wrapper::*default_getDataPointer_function_type)(  ) const;
            
            Image_exposer.def( 
                "getDataPointer"
                , getDataPointer_function_type(&::osg::Image::getDataPointer)
                , default_getDataPointer_function_type(&Image_wrapper::default_getDataPointer)
                , bp::return_value_policy< bp::return_opaque_pointer >() );
        
        }
        { //::osg::Image::getDataType
        
            typedef ::GLenum ( ::osg::Image::*getDataType_function_type)(  ) const;
            
            Image_exposer.def( 
                "getDataType"
                , getDataType_function_type( &::osg::Image::getDataType ) );
        
        }
        { //::osg::Image::getFileName
        
            typedef ::std::string const & ( ::osg::Image::*getFileName_function_type)(  ) const;
            
            Image_exposer.def( 
                "getFileName"
                , getFileName_function_type( &::osg::Image::getFileName )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::osg::Image::getImageSizeInBytes
        
            typedef unsigned int ( ::osg::Image::*getImageSizeInBytes_function_type)(  ) const;
            
            Image_exposer.def( 
                "getImageSizeInBytes"
                , getImageSizeInBytes_function_type( &::osg::Image::getImageSizeInBytes )
                , " Return the number of bytes each image (_s*_t) of pixels occupies." );
        
        }
        { //::osg::Image::getImageStepInBytes
        
            typedef unsigned int ( ::osg::Image::*getImageStepInBytes_function_type)(  ) const;
            
            Image_exposer.def( 
                "getImageStepInBytes"
                , getImageStepInBytes_function_type( &::osg::Image::getImageStepInBytes )
                , " Return the number of bytes between each successive image.\n Note, getImageSizeInBytes() will only equal getImageStepInBytes() when isDataContiguous() return true." );
        
        }
        { //::osg::Image::getInternalTextureFormat
        
            typedef ::GLint ( ::osg::Image::*getInternalTextureFormat_function_type)(  ) const;
            
            Image_exposer.def( 
                "getInternalTextureFormat"
                , getInternalTextureFormat_function_type( &::osg::Image::getInternalTextureFormat ) );
        
        }
        { //::osg::Image::getMipmapLevels
        
            typedef ::std::vector< unsigned int > const & ( ::osg::Image::*getMipmapLevels_function_type)(  ) const;
            
            Image_exposer.def( 
                "getMipmapLevels"
                , getMipmapLevels_function_type( &::osg::Image::getMipmapLevels )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Image::getMipmapOffset
        
            typedef unsigned int ( ::osg::Image::*getMipmapOffset_function_type)( unsigned int ) const;
            
            Image_exposer.def( 
                "getMipmapOffset"
                , getMipmapOffset_function_type( &::osg::Image::getMipmapOffset )
                , ( bp::arg("mipmapLevel") ) );
        
        }
        { //::osg::Image::getNumMipmapLevels
        
            typedef unsigned int ( ::osg::Image::*getNumMipmapLevels_function_type)(  ) const;
            
            Image_exposer.def( 
                "getNumMipmapLevels"
                , getNumMipmapLevels_function_type( &::osg::Image::getNumMipmapLevels ) );
        
        }
        { //::osg::Image::getOrigin
        
            typedef ::osg::Image::Origin ( ::osg::Image::*getOrigin_function_type)(  ) const;
            
            Image_exposer.def( 
                "getOrigin"
                , getOrigin_function_type( &::osg::Image::getOrigin )
                , " Get the origin of the image." );
        
        }
        { //::osg::Image::getPacking
        
            typedef unsigned int ( ::osg::Image::*getPacking_function_type)(  ) const;
            
            Image_exposer.def( 
                "getPacking"
                , getPacking_function_type( &::osg::Image::getPacking ) );
        
        }
        { //::osg::Image::getPixelAspectRatio
        
            typedef float ( ::osg::Image::*getPixelAspectRatio_function_type)(  ) const;
            
            Image_exposer.def( 
                "getPixelAspectRatio"
                , getPixelAspectRatio_function_type( &::osg::Image::getPixelAspectRatio )
                , " Get the pixel aspect ratio." );
        
        }
        { //::osg::Image::getPixelBufferObject
        
            typedef ::osg::PixelBufferObject * ( ::osg::Image::*getPixelBufferObject_function_type)(  ) ;
            
            Image_exposer.def( 
                "getPixelBufferObject"
                , getPixelBufferObject_function_type( &::osg::Image::getPixelBufferObject )
                , bp::return_internal_reference< >()
                , " Get the PixelBufferObject." );
        
        }
        { //::osg::Image::getPixelBufferObject
        
            typedef ::osg::PixelBufferObject const * ( ::osg::Image::*getPixelBufferObject_function_type)(  ) const;
            
            Image_exposer.def( 
                "getPixelBufferObject"
                , getPixelBufferObject_function_type( &::osg::Image::getPixelBufferObject )
                , bp::return_internal_reference< >()
                , " Get the const PixelBufferObject." );
        
        }
        { //::osg::Image::getPixelFormat
        
            typedef ::GLenum ( ::osg::Image::*getPixelFormat_function_type)(  ) const;
            
            Image_exposer.def( 
                "getPixelFormat"
                , getPixelFormat_function_type( &::osg::Image::getPixelFormat ) );
        
        }
        { //::osg::Image::getPixelSizeInBits
        
            typedef unsigned int ( ::osg::Image::*getPixelSizeInBits_function_type)(  ) const;
            
            Image_exposer.def( 
                "getPixelSizeInBits"
                , getPixelSizeInBits_function_type( &::osg::Image::getPixelSizeInBits )
                , " Return the number of bits required for each pixel." );
        
        }
        { //::osg::Image::getRowLength
        
            typedef int ( ::osg::Image::*getRowLength_function_type)(  ) const;
            
            Image_exposer.def( 
                "getRowLength"
                , getRowLength_function_type( &::osg::Image::getRowLength ) );
        
        }
        { //::osg::Image::getRowSizeInBytes
        
            typedef unsigned int ( ::osg::Image::*getRowSizeInBytes_function_type)(  ) const;
            
            Image_exposer.def( 
                "getRowSizeInBytes"
                , getRowSizeInBytes_function_type( &::osg::Image::getRowSizeInBytes )
                , " Return the number of bytes each row of pixels occupies once it has been packed." );
        
        }
        { //::osg::Image::getRowStepInBytes
        
            typedef unsigned int ( ::osg::Image::*getRowStepInBytes_function_type)(  ) const;
            
            Image_exposer.def( 
                "getRowStepInBytes"
                , getRowStepInBytes_function_type( &::osg::Image::getRowStepInBytes )
                , " Return the number of bytes between each successive row.\n Note, getRowSizeInBytes() will only equal getRowStepInBytes() when isDataContiguous() return true." );
        
        }
        { //::osg::Image::getTotalDataSize
        
            typedef unsigned int ( ::osg::Image::*getTotalDataSize_function_type)(  ) const;
            typedef unsigned int ( Image_wrapper::*default_getTotalDataSize_function_type)(  ) const;
            
            Image_exposer.def( 
                "getTotalDataSize"
                , getTotalDataSize_function_type(&::osg::Image::getTotalDataSize)
                , default_getTotalDataSize_function_type(&Image_wrapper::default_getTotalDataSize) );
        
        }
        { //::osg::Image::getTotalSizeInBytes
        
            typedef unsigned int ( ::osg::Image::*getTotalSizeInBytes_function_type)(  ) const;
            
            Image_exposer.def( 
                "getTotalSizeInBytes"
                , getTotalSizeInBytes_function_type( &::osg::Image::getTotalSizeInBytes )
                , " Return the number of bytes the whole row/image/volume of pixels occupies." );
        
        }
        { //::osg::Image::getTotalSizeInBytesIncludingMipmaps
        
            typedef unsigned int ( ::osg::Image::*getTotalSizeInBytesIncludingMipmaps_function_type)(  ) const;
            
            Image_exposer.def( 
                "getTotalSizeInBytesIncludingMipmaps"
                , getTotalSizeInBytesIncludingMipmaps_function_type( &::osg::Image::getTotalSizeInBytesIncludingMipmaps )
                , " Return the number of bytes the whole row/image/volume of pixels occupies, including all mip maps if included." );
        
        }
        { //::osg::Image::getWriteHint
        
            typedef ::osg::Image::WriteHint ( ::osg::Image::*getWriteHint_function_type)(  ) const;
            
            Image_exposer.def( 
                "getWriteHint"
                , getWriteHint_function_type( &::osg::Image::getWriteHint ) );
        
        }
        { //::osg::Image::isCompressed
        
            typedef bool ( ::osg::Image::*isCompressed_function_type)(  ) const;
            
            Image_exposer.def( 
                "isCompressed"
                , isCompressed_function_type( &::osg::Image::isCompressed )
                , " Return true of the pixel format is an OpenGL compressed pixel format." );
        
        }
        { //::osg::Image::isDataContiguous
        
            typedef bool ( ::osg::Image::*isDataContiguous_function_type)(  ) const;
            
            Image_exposer.def( 
                "isDataContiguous"
                , isDataContiguous_function_type( &::osg::Image::isDataContiguous )
                , " return true if the data stored in the image is a contiguous block of data." );
        
        }
        { //::osg::Image::isImageTranslucent
        
            typedef bool ( ::osg::Image::*isImageTranslucent_function_type)(  ) const;
            typedef bool ( Image_wrapper::*default_isImageTranslucent_function_type)(  ) const;
            
            Image_exposer.def( 
                "isImageTranslucent"
                , isImageTranslucent_function_type(&::osg::Image::isImageTranslucent)
                , default_isImageTranslucent_function_type(&Image_wrapper::default_isImageTranslucent) );
        
        }
        { //::osg::Image::isMipmap
        
            typedef bool ( ::osg::Image::*isMipmap_function_type)(  ) const;
            
            Image_exposer.def( 
                "isMipmap"
                , isMipmap_function_type( &::osg::Image::isMipmap ) );
        
        }
        { //::osg::Image::isPackedType
        
            typedef bool ( *isPackedType_function_type )( ::GLenum );
            
            Image_exposer.def( 
                "isPackedType"
                , isPackedType_function_type( &::osg::Image::isPackedType )
                , ( bp::arg("type") ) );
        
        }
        { //::osg::Image::isSameKindAs
        
            typedef bool ( ::osg::Image::*isSameKindAs_function_type)( ::osg::Object const * ) const;
            typedef bool ( Image_wrapper::*default_isSameKindAs_function_type)( ::osg::Object const * ) const;
            
            Image_exposer.def( 
                "isSameKindAs"
                , isSameKindAs_function_type(&::osg::Image::isSameKindAs)
                , default_isSameKindAs_function_type(&Image_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) );
        
        }
        { //::osg::Image::libraryName
        
            typedef char const * ( ::osg::Image::*libraryName_function_type)(  ) const;
            typedef char const * ( Image_wrapper::*default_libraryName_function_type)(  ) const;
            
            Image_exposer.def( 
                "libraryName"
                , libraryName_function_type(&::osg::Image::libraryName)
                , default_libraryName_function_type(&Image_wrapper::default_libraryName) );
        
        }
        { //::osg::Image::r
        
            typedef int ( ::osg::Image::*r_function_type)(  ) const;
            
            Image_exposer.def( 
                "r"
                , r_function_type( &::osg::Image::r )
                , " Depth of image." );
        
        }
        { //::osg::Image::readImageFromCurrentTexture
        
            typedef void ( ::osg::Image::*readImageFromCurrentTexture_function_type)( unsigned int,bool,::GLenum,unsigned int ) ;
            typedef void ( Image_wrapper::*default_readImageFromCurrentTexture_function_type)( unsigned int,bool,::GLenum,unsigned int ) ;
            
            Image_exposer.def( 
                "readImageFromCurrentTexture"
                , readImageFromCurrentTexture_function_type(&::osg::Image::readImageFromCurrentTexture)
                , default_readImageFromCurrentTexture_function_type(&Image_wrapper::default_readImageFromCurrentTexture)
                , ( bp::arg("contextID"), bp::arg("copyMipMapsIfAvailable"), bp::arg("type")=(::GLenum)(5121), bp::arg("face")=(unsigned int)(0) ) );
        
        }
        { //::osg::Image::readPixels
        
            typedef void ( ::osg::Image::*readPixels_function_type)( int,int,int,int,::GLenum,::GLenum,int ) ;
            typedef void ( Image_wrapper::*default_readPixels_function_type)( int,int,int,int,::GLenum,::GLenum,int ) ;
            
            Image_exposer.def( 
                "readPixels"
                , readPixels_function_type(&::osg::Image::readPixels)
                , default_readPixels_function_type(&Image_wrapper::default_readPixels)
                , ( bp::arg("x"), bp::arg("y"), bp::arg("width"), bp::arg("height"), bp::arg("pixelFormat"), bp::arg("type"), bp::arg("packing")=(int)(1) ) );
        
        }
        { //::osg::Image::removeDimensionsChangedCallback
        
            typedef void ( ::osg::Image::*removeDimensionsChangedCallback_function_type)( ::osg::Image::DimensionsChangedCallback * ) ;
            
            Image_exposer.def( 
                "removeDimensionsChangedCallback"
                , removeDimensionsChangedCallback_function_type( &::osg::Image::removeDimensionsChangedCallback )
                , ( bp::arg("cb") ) );
        
        }
        { //::osg::Image::requiresUpdateCall
        
            typedef bool ( ::osg::Image::*requiresUpdateCall_function_type)(  ) const;
            typedef bool ( Image_wrapper::*default_requiresUpdateCall_function_type)(  ) const;
            
            Image_exposer.def( 
                "requiresUpdateCall"
                , requiresUpdateCall_function_type(&::osg::Image::requiresUpdateCall)
                , default_requiresUpdateCall_function_type(&Image_wrapper::default_requiresUpdateCall) );
        
        }
        { //::osg::Image::s
        
            typedef int ( ::osg::Image::*s_function_type)(  ) const;
            
            Image_exposer.def( 
                "s"
                , s_function_type( &::osg::Image::s )
                , " Width of image." );
        
        }
        { //::osg::Image::scaleImage
        
            typedef void ( ::osg::Image::*scaleImage_function_type)( int,int,int ) ;
            
            Image_exposer.def( 
                "scaleImage"
                , scaleImage_function_type( &::osg::Image::scaleImage )
                , ( bp::arg("s"), bp::arg("t"), bp::arg("r") )
                , " Scale image to specified size." );
        
        }
        { //::osg::Image::scaleImage
        
            typedef void ( ::osg::Image::*scaleImage_function_type)( int,int,int,::GLenum ) ;
            typedef void ( Image_wrapper::*default_scaleImage_function_type)( int,int,int,::GLenum ) ;
            
            Image_exposer.def( 
                "scaleImage"
                , scaleImage_function_type(&::osg::Image::scaleImage)
                , default_scaleImage_function_type(&Image_wrapper::default_scaleImage)
                , ( bp::arg("s"), bp::arg("t"), bp::arg("r"), bp::arg("newDataType") ) );
        
        }
        { //::osg::Image::sendFocusHint
        
            typedef bool ( ::osg::Image::*sendFocusHint_function_type)( bool ) ;
            typedef bool ( Image_wrapper::*default_sendFocusHint_function_type)( bool ) ;
            
            Image_exposer.def( 
                "sendFocusHint"
                , sendFocusHint_function_type(&::osg::Image::sendFocusHint)
                , default_sendFocusHint_function_type(&Image_wrapper::default_sendFocusHint)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Image::sendKeyEvent
        
            typedef bool ( ::osg::Image::*sendKeyEvent_function_type)( int,bool ) ;
            typedef bool ( Image_wrapper::*default_sendKeyEvent_function_type)( int,bool ) ;
            
            Image_exposer.def( 
                "sendKeyEvent"
                , sendKeyEvent_function_type(&::osg::Image::sendKeyEvent)
                , default_sendKeyEvent_function_type(&Image_wrapper::default_sendKeyEvent)
                , ( bp::arg("arg0"), bp::arg("arg1") ) );
        
        }
        { //::osg::Image::sendPointerEvent
        
            typedef bool ( ::osg::Image::*sendPointerEvent_function_type)( int,int,int ) ;
            typedef bool ( Image_wrapper::*default_sendPointerEvent_function_type)( int,int,int ) ;
            
            Image_exposer.def( 
                "sendPointerEvent"
                , sendPointerEvent_function_type(&::osg::Image::sendPointerEvent)
                , default_sendPointerEvent_function_type(&Image_wrapper::default_sendPointerEvent)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) );
        
        }
        { //::osg::Image::setAllocationMode
        
            typedef void ( ::osg::Image::*setAllocationMode_function_type)( ::osg::Image::AllocationMode ) ;
            
            Image_exposer.def( 
                "setAllocationMode"
                , setAllocationMode_function_type( &::osg::Image::setAllocationMode )
                , ( bp::arg("mode") )
                , " Set the method used for deleting data once it goes out of scope." );
        
        }
        { //::osg::Image::setDataType
        
            typedef void ( ::osg::Image::*setDataType_function_type)( ::GLenum ) ;
            
            Image_exposer.def( 
                "setDataType"
                , setDataType_function_type( &::osg::Image::setDataType )
                , ( bp::arg("dataType") ) );
        
        }
        { //::osg::Image::setFileName
        
            typedef void ( ::osg::Image::*setFileName_function_type)( ::std::string const & ) ;
            
            Image_exposer.def( 
                "setFileName"
                , setFileName_function_type( &::osg::Image::setFileName )
                , ( bp::arg("fileName") ) );
        
        }
        { //::osg::Image::setFrameLastRendered
        
            typedef void ( ::osg::Image::*setFrameLastRendered_function_type)( ::osg::FrameStamp const * ) ;
            typedef void ( Image_wrapper::*default_setFrameLastRendered_function_type)( ::osg::FrameStamp const * ) ;
            
            Image_exposer.def( 
                "setFrameLastRendered"
                , setFrameLastRendered_function_type(&::osg::Image::setFrameLastRendered)
                , default_setFrameLastRendered_function_type(&Image_wrapper::default_setFrameLastRendered)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Image::setImage
        
            typedef void ( ::osg::Image::*setImage_function_type)( int,int,int,::GLint,::GLenum,::GLenum,unsigned char *,::osg::Image::AllocationMode,int,int ) ;
            typedef void ( Image_wrapper::*default_setImage_function_type)( int,int,int,::GLint,::GLenum,::GLenum,unsigned char *,::osg::Image::AllocationMode,int,int ) ;
            
            Image_exposer.def( 
                "setImage"
                , setImage_function_type(&::osg::Image::setImage)
                , default_setImage_function_type(&Image_wrapper::default_setImage)
                , ( bp::arg("s"), bp::arg("t"), bp::arg("r"), bp::arg("internalTextureformat"), bp::arg("pixelFormat"), bp::arg("type"), bp::arg("data"), bp::arg("mode"), bp::arg("packing")=(int)(1), bp::arg("rowLength")=(int)(0) ) );
        
        }
        { //::osg::Image::setInternalTextureFormat
        
            typedef void ( ::osg::Image::*setInternalTextureFormat_function_type)( ::GLint ) ;
            
            Image_exposer.def( 
                "setInternalTextureFormat"
                , setInternalTextureFormat_function_type( &::osg::Image::setInternalTextureFormat )
                , ( bp::arg("internalFormat") ) );
        
        }
        { //::osg::Image::setMipmapLevels
        
            typedef void ( ::osg::Image::*setMipmapLevels_function_type)( ::std::vector< unsigned int > const & ) ;
            
            Image_exposer.def( 
                "setMipmapLevels"
                , setMipmapLevels_function_type( &::osg::Image::setMipmapLevels )
                , ( bp::arg("mipmapDataVector") )
                , " Send offsets into data. It is assumed that first mipmap offset (index 0) is 0." );
        
        }
        { //::osg::Image::setOrigin
        
            typedef void ( ::osg::Image::*setOrigin_function_type)( ::osg::Image::Origin ) ;
            
            Image_exposer.def( 
                "setOrigin"
                , setOrigin_function_type( &::osg::Image::setOrigin )
                , ( bp::arg("origin") )
                , " Set the origin of the image.\n The default value is BOTTOM_LEFT and is consistent with OpenGL.\n TOP_LEFT is used for imagery that follows standard Imagery convention, such as movies,\n and hasnt been flipped yet.  For such images one much flip the t axis of the tex coords.\n to handle this origin position." );
        
        }
        { //::osg::Image::setPacking
        
            typedef void ( ::osg::Image::*setPacking_function_type)( unsigned int ) ;
            
            Image_exposer.def( 
                "setPacking"
                , setPacking_function_type( &::osg::Image::setPacking )
                , ( bp::arg("packing") ) );
        
        }
        { //::osg::Image::setPixelAspectRatio
        
            typedef void ( ::osg::Image::*setPixelAspectRatio_function_type)( float ) ;
            
            Image_exposer.def( 
                "setPixelAspectRatio"
                , setPixelAspectRatio_function_type( &::osg::Image::setPixelAspectRatio )
                , ( bp::arg("pixelAspectRatio") )
                , " Set the pixel aspect ratio, defined as the pixel width divided by the pixel height." );
        
        }
        { //::osg::Image::setPixelBufferObject
        
            typedef void ( ::osg::Image::*setPixelBufferObject_function_type)( ::osg::PixelBufferObject * ) ;
            
            Image_exposer.def( 
                "setPixelBufferObject"
                , setPixelBufferObject_function_type( &::osg::Image::setPixelBufferObject )
                , ( bp::arg("buffer") )
                , " Set the optional PixelBufferObject used to map the image memory efficiently to graphics memory." );
        
        }
        { //::osg::Image::setPixelFormat
        
            typedef void ( ::osg::Image::*setPixelFormat_function_type)( ::GLenum ) ;
            
            Image_exposer.def( 
                "setPixelFormat"
                , setPixelFormat_function_type( &::osg::Image::setPixelFormat )
                , ( bp::arg("pixelFormat") ) );
        
        }
        { //::osg::Image::setRowLength
        
            typedef void ( ::osg::Image::*setRowLength_function_type)( int ) ;
            
            Image_exposer.def( 
                "setRowLength"
                , setRowLength_function_type( &::osg::Image::setRowLength )
                , ( bp::arg("length") ) );
        
        }
        { //::osg::Image::setWriteHint
        
            typedef void ( ::osg::Image::*setWriteHint_function_type)( ::osg::Image::WriteHint ) ;
            
            Image_exposer.def( 
                "setWriteHint"
                , setWriteHint_function_type( &::osg::Image::setWriteHint )
                , ( bp::arg("writeHint") ) );
        
        }
        { //::osg::Image::supportsTextureSubloading
        
            typedef bool ( ::osg::Image::*supportsTextureSubloading_function_type)(  ) const;
            
            Image_exposer.def( 
                "supportsTextureSubloading"
                , supportsTextureSubloading_function_type( &::osg::Image::supportsTextureSubloading )
                , " returns false for texture formats that do not support texture subloading" );
        
        }
        { //::osg::Image::swap
        
            typedef void ( ::osg::Image::*swap_function_type)( ::osg::Image & ) ;
            
            Image_exposer.def( 
                "swap"
                , swap_function_type( &::osg::Image::swap )
                , ( bp::arg("rhs") )
                , " swap the data and settings between two image objects." );
        
        }
        { //::osg::Image::t
        
            typedef int ( ::osg::Image::*t_function_type)(  ) const;
            
            Image_exposer.def( 
                "t"
                , t_function_type( &::osg::Image::t )
                , " Height of image." );
        
        }
        { //::osg::Image::update
        
            typedef void ( ::osg::Image::*update_function_type)( ::osg::NodeVisitor * ) ;
            typedef void ( Image_wrapper::*default_update_function_type)( ::osg::NodeVisitor * ) ;
            
            Image_exposer.def( 
                "update"
                , update_function_type(&::osg::Image::update)
                , default_update_function_type(&Image_wrapper::default_update)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Image::valid
        
            typedef bool ( ::osg::Image::*valid_function_type)(  ) const;
            
            Image_exposer.def( 
                "valid"
                , valid_function_type( &::osg::Image::valid )
                , " Return true if the Image represent a valid and usable imagery." );
        
        }
        { //::osg::BufferData::asArray
        
            typedef ::osg::Array * ( ::osg::BufferData::*asArray_function_type)(  ) ;
            typedef ::osg::Array * ( Image_wrapper::*default_asArray_function_type)(  ) ;
            
            Image_exposer.def( 
                "asArray"
                , asArray_function_type(&::osg::BufferData::asArray)
                , default_asArray_function_type(&Image_wrapper::default_asArray)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::BufferData::asArray
        
            typedef ::osg::Array const * ( ::osg::BufferData::*asArray_function_type)(  ) const;
            typedef ::osg::Array const * ( Image_wrapper::*default_asArray_function_type)(  ) const;
            
            Image_exposer.def( 
                "asArray"
                , asArray_function_type(&::osg::BufferData::asArray)
                , default_asArray_function_type(&Image_wrapper::default_asArray)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Object::computeDataVariance
        
            typedef void ( ::osg::Object::*computeDataVariance_function_type)(  ) ;
            typedef void ( Image_wrapper::*default_computeDataVariance_function_type)(  ) ;
            
            Image_exposer.def( 
                "computeDataVariance"
                , computeDataVariance_function_type(&::osg::Object::computeDataVariance)
                , default_computeDataVariance_function_type(&Image_wrapper::default_computeDataVariance) );
        
        }
        { //::osg::Object::getUserData
        
            typedef ::osg::Referenced * ( ::osg::Object::*getUserData_function_type)(  ) ;
            typedef ::osg::Referenced * ( Image_wrapper::*default_getUserData_function_type)(  ) ;
            
            Image_exposer.def( 
                "getUserData"
                , getUserData_function_type(&::osg::Object::getUserData)
                , default_getUserData_function_type(&Image_wrapper::default_getUserData)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Object::getUserData
        
            typedef ::osg::Referenced const * ( ::osg::Object::*getUserData_function_type)(  ) const;
            typedef ::osg::Referenced const * ( Image_wrapper::*default_getUserData_function_type)(  ) const;
            
            Image_exposer.def( 
                "getUserData"
                , getUserData_function_type(&::osg::Object::getUserData)
                , default_getUserData_function_type(&Image_wrapper::default_getUserData)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::BufferData::resizeGLObjectBuffers
        
            typedef void ( ::osg::BufferData::*resizeGLObjectBuffers_function_type)( unsigned int ) ;
            typedef void ( Image_wrapper::*default_resizeGLObjectBuffers_function_type)( unsigned int ) ;
            
            Image_exposer.def( 
                "resizeGLObjectBuffers"
                , resizeGLObjectBuffers_function_type(&::osg::BufferData::resizeGLObjectBuffers)
                , default_resizeGLObjectBuffers_function_type(&Image_wrapper::default_resizeGLObjectBuffers)
                , ( bp::arg("maxSize") ) );
        
        }
        { //::osg::Object::setName
        
            typedef void ( ::osg::Object::*setName_function_type)( ::std::string const & ) ;
            typedef void ( Image_wrapper::*default_setName_function_type)( ::std::string const & ) ;
            
            Image_exposer.def( 
                "setName"
                , setName_function_type(&::osg::Object::setName)
                , default_setName_function_type(&Image_wrapper::default_setName)
                , ( bp::arg("name") ) );
        
        }
        { //::osg::Object::setName
        
            typedef void ( ::osg::Object::*setName_function_type)( char const * ) ;
            
            Image_exposer.def( 
                "setName"
                , setName_function_type( &::osg::Object::setName )
                , ( bp::arg("name") )
                , " Set the name of object using a C style string." );
        
        }
        { //::osg::Object::setThreadSafeRefUnref
        
            typedef void ( ::osg::Object::*setThreadSafeRefUnref_function_type)( bool ) ;
            typedef void ( Image_wrapper::*default_setThreadSafeRefUnref_function_type)( bool ) ;
            
            Image_exposer.def( 
                "setThreadSafeRefUnref"
                , setThreadSafeRefUnref_function_type(&::osg::Object::setThreadSafeRefUnref)
                , default_setThreadSafeRefUnref_function_type(&Image_wrapper::default_setThreadSafeRefUnref)
                , ( bp::arg("threadSafe") ) );
        
        }
        { //::osg::Object::setUserData
        
            typedef void ( ::osg::Object::*setUserData_function_type)( ::osg::Referenced * ) ;
            typedef void ( Image_wrapper::*default_setUserData_function_type)( ::osg::Referenced * ) ;
            
            Image_exposer.def( 
                "setUserData"
                , setUserData_function_type(&::osg::Object::setUserData)
                , default_setUserData_function_type(&Image_wrapper::default_setUserData)
                , ( bp::arg("obj") ) );
        
        }
        Image_exposer.staticmethod( "computeBlockSize" );
        Image_exposer.staticmethod( "computeFormatDataType" );
        Image_exposer.staticmethod( "computeImageSizeInBytes" );
        Image_exposer.staticmethod( "computeNearestPowerOfTwo" );
        Image_exposer.staticmethod( "computeNumComponents" );
        Image_exposer.staticmethod( "computeNumberOfMipmapLevels" );
        Image_exposer.staticmethod( "computePixelFormat" );
        Image_exposer.staticmethod( "computePixelSizeInBits" );
        Image_exposer.staticmethod( "computeRowWidthInBytes" );
        Image_exposer.staticmethod( "isPackedType" );
    }

}
