// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osgsim.h"
#include "wrap_referenced.h"
#include "impostor.pypp.hpp"

namespace bp = boost::python;

struct Impostor_wrapper : osgSim::Impostor, bp::wrapper< osgSim::Impostor > {

    Impostor_wrapper( )
    : osgSim::Impostor( )
      , bp::wrapper< osgSim::Impostor >(){
        // null constructor
    
    }

    virtual void accept( ::osg::NodeVisitor & nv ) {
        if( bp::override func_accept = this->get_override( "accept" ) )
            func_accept( boost::ref(nv) );
        else{
            this->osgSim::Impostor::accept( boost::ref(nv) );
        }
    }
    
    void default_accept( ::osg::NodeVisitor & nv ) {
        osgSim::Impostor::accept( boost::ref(nv) );
    }

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osgSim::Impostor::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osgSim::Impostor::className( );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone( boost::ref(copyop) );
        else{
            return this->osgSim::Impostor::clone( boost::ref(copyop) );
        }
    }
    
    ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
        return osgSim::Impostor::clone( boost::ref(copyop) );
    }

    virtual ::osg::Object * cloneType(  ) const  {
        if( bp::override func_cloneType = this->get_override( "cloneType" ) )
            return func_cloneType(  );
        else{
            return this->osgSim::Impostor::cloneType(  );
        }
    }
    
    ::osg::Object * default_cloneType(  ) const  {
        return osgSim::Impostor::cloneType( );
    }

    virtual ::osg::BoundingSphere computeBound(  ) const  {
        if( bp::override func_computeBound = this->get_override( "computeBound" ) )
            return func_computeBound(  );
        else{
            return this->osgSim::Impostor::computeBound(  );
        }
    }
    
    ::osg::BoundingSphere default_computeBound(  ) const  {
        return osgSim::Impostor::computeBound( );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osgSim::Impostor::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osgSim::Impostor::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osgSim::Impostor::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osgSim::Impostor::libraryName( );
    }

    virtual void traverse( ::osg::NodeVisitor & nv ) {
        if( bp::override func_traverse = this->get_override( "traverse" ) )
            func_traverse( boost::ref(nv) );
        else{
            this->osgSim::Impostor::traverse( boost::ref(nv) );
        }
    }
    
    void default_traverse( ::osg::NodeVisitor & nv ) {
        osgSim::Impostor::traverse( boost::ref(nv) );
    }

    virtual bool addChild( ::osg::Node * child ) {
        if( bp::override func_addChild = this->get_override( "addChild" ) )
            return func_addChild( boost::python::ptr(child) );
        else{
            return this->osg::LOD::addChild( boost::python::ptr(child) );
        }
    }
    
    bool default_addChild( ::osg::Node * child ) {
        return osg::LOD::addChild( boost::python::ptr(child) );
    }

    virtual bool addChild( ::osg::Node * child, float min, float max ) {
        if( bp::override func_addChild = this->get_override( "addChild" ) )
            return func_addChild( boost::python::ptr(child), min, max );
        else{
            return this->osg::LOD::addChild( boost::python::ptr(child), min, max );
        }
    }
    
    bool default_addChild( ::osg::Node * child, float min, float max ) {
        return osg::LOD::addChild( boost::python::ptr(child), min, max );
    }

    virtual ::osg::Camera * asCamera(  ) {
        if( bp::override func_asCamera = this->get_override( "asCamera" ) )
            return func_asCamera(  );
        else{
            return this->osg::Node::asCamera(  );
        }
    }
    
    ::osg::Camera * default_asCamera(  ) {
        return osg::Node::asCamera( );
    }

    virtual ::osg::Camera const * asCamera(  ) const  {
        if( bp::override func_asCamera = this->get_override( "asCamera" ) )
            return func_asCamera(  );
        else{
            return this->osg::Node::asCamera(  );
        }
    }
    
    ::osg::Camera const * default_asCamera(  ) const  {
        return osg::Node::asCamera( );
    }

    virtual ::osg::Geode * asGeode(  ) {
        if( bp::override func_asGeode = this->get_override( "asGeode" ) )
            return func_asGeode(  );
        else{
            return this->osg::Node::asGeode(  );
        }
    }
    
    ::osg::Geode * default_asGeode(  ) {
        return osg::Node::asGeode( );
    }

    virtual ::osg::Geode const * asGeode(  ) const  {
        if( bp::override func_asGeode = this->get_override( "asGeode" ) )
            return func_asGeode(  );
        else{
            return this->osg::Node::asGeode(  );
        }
    }
    
    ::osg::Geode const * default_asGeode(  ) const  {
        return osg::Node::asGeode( );
    }

    virtual ::osg::Group * asGroup(  ) {
        if( bp::override func_asGroup = this->get_override( "asGroup" ) )
            return func_asGroup(  );
        else{
            return this->osg::Group::asGroup(  );
        }
    }
    
    ::osg::Group * default_asGroup(  ) {
        return osg::Group::asGroup( );
    }

    virtual ::osg::Group const * asGroup(  ) const  {
        if( bp::override func_asGroup = this->get_override( "asGroup" ) )
            return func_asGroup(  );
        else{
            return this->osg::Group::asGroup(  );
        }
    }
    
    ::osg::Group const * default_asGroup(  ) const  {
        return osg::Group::asGroup( );
    }

    virtual ::osg::Switch * asSwitch(  ) {
        if( bp::override func_asSwitch = this->get_override( "asSwitch" ) )
            return func_asSwitch(  );
        else{
            return this->osg::Node::asSwitch(  );
        }
    }
    
    ::osg::Switch * default_asSwitch(  ) {
        return osg::Node::asSwitch( );
    }

    virtual ::osg::Switch const * asSwitch(  ) const  {
        if( bp::override func_asSwitch = this->get_override( "asSwitch" ) )
            return func_asSwitch(  );
        else{
            return this->osg::Node::asSwitch(  );
        }
    }
    
    ::osg::Switch const * default_asSwitch(  ) const  {
        return osg::Node::asSwitch( );
    }

    virtual ::osg::Transform * asTransform(  ) {
        if( bp::override func_asTransform = this->get_override( "asTransform" ) )
            return func_asTransform(  );
        else{
            return this->osg::Node::asTransform(  );
        }
    }
    
    ::osg::Transform * default_asTransform(  ) {
        return osg::Node::asTransform( );
    }

    virtual ::osg::Transform const * asTransform(  ) const  {
        if( bp::override func_asTransform = this->get_override( "asTransform" ) )
            return func_asTransform(  );
        else{
            return this->osg::Node::asTransform(  );
        }
    }
    
    ::osg::Transform const * default_asTransform(  ) const  {
        return osg::Node::asTransform( );
    }

    virtual void ascend( ::osg::NodeVisitor & nv ) {
        if( bp::override func_ascend = this->get_override( "ascend" ) )
            func_ascend( boost::ref(nv) );
        else{
            this->osg::Node::ascend( boost::ref(nv) );
        }
    }
    
    void default_ascend( ::osg::NodeVisitor & nv ) {
        osg::Node::ascend( boost::ref(nv) );
    }

    virtual void computeDataVariance(  ) {
        if( bp::override func_computeDataVariance = this->get_override( "computeDataVariance" ) )
            func_computeDataVariance(  );
        else{
            this->osg::Object::computeDataVariance(  );
        }
    }
    
    void default_computeDataVariance(  ) {
        osg::Object::computeDataVariance( );
    }

    virtual ::osg::Referenced * getUserData(  ) {
        if( bp::override func_getUserData = this->get_override( "getUserData" ) )
            return func_getUserData(  );
        else{
            return this->osg::Object::getUserData(  );
        }
    }
    
    ::osg::Referenced * default_getUserData(  ) {
        return osg::Object::getUserData( );
    }

    virtual ::osg::Referenced const * getUserData(  ) const  {
        if( bp::override func_getUserData = this->get_override( "getUserData" ) )
            return func_getUserData(  );
        else{
            return this->osg::Object::getUserData(  );
        }
    }
    
    ::osg::Referenced const * default_getUserData(  ) const  {
        return osg::Object::getUserData( );
    }

    virtual bool insertChild( unsigned int index, ::osg::Node * child ) {
        if( bp::override func_insertChild = this->get_override( "insertChild" ) )
            return func_insertChild( index, boost::python::ptr(child) );
        else{
            return this->osg::Group::insertChild( index, boost::python::ptr(child) );
        }
    }
    
    bool default_insertChild( unsigned int index, ::osg::Node * child ) {
        return osg::Group::insertChild( index, boost::python::ptr(child) );
    }

    virtual bool removeChildren( unsigned int pos, unsigned int numChildrenToRemove=1 ) {
        if( bp::override func_removeChildren = this->get_override( "removeChildren" ) )
            return func_removeChildren( pos, numChildrenToRemove );
        else{
            return this->osg::LOD::removeChildren( pos, numChildrenToRemove );
        }
    }
    
    bool default_removeChildren( unsigned int pos, unsigned int numChildrenToRemove=1 ) {
        return osg::LOD::removeChildren( pos, numChildrenToRemove );
    }

    virtual bool replaceChild( ::osg::Node * origChild, ::osg::Node * newChild ) {
        if( bp::override func_replaceChild = this->get_override( "replaceChild" ) )
            return func_replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
        else{
            return this->osg::Group::replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
        }
    }
    
    bool default_replaceChild( ::osg::Node * origChild, ::osg::Node * newChild ) {
        return osg::Group::replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
    }

    virtual void resizeGLObjectBuffers( unsigned int maxSize ) {
        if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
            func_resizeGLObjectBuffers( maxSize );
        else{
            this->osg::Group::resizeGLObjectBuffers( maxSize );
        }
    }
    
    void default_resizeGLObjectBuffers( unsigned int maxSize ) {
        osg::Group::resizeGLObjectBuffers( maxSize );
    }

    virtual bool setChild( unsigned int i, ::osg::Node * node ) {
        if( bp::override func_setChild = this->get_override( "setChild" ) )
            return func_setChild( i, boost::python::ptr(node) );
        else{
            return this->osg::Group::setChild( i, boost::python::ptr(node) );
        }
    }
    
    bool default_setChild( unsigned int i, ::osg::Node * node ) {
        return osg::Group::setChild( i, boost::python::ptr(node) );
    }

    virtual void setName( ::std::string const & name ) {
        if( bp::override func_setName = this->get_override( "setName" ) )
            func_setName( name );
        else{
            this->osg::Object::setName( name );
        }
    }
    
    void default_setName( ::std::string const & name ) {
        osg::Object::setName( name );
    }

    virtual void setThreadSafeRefUnref( bool threadSafe ) {
        if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
            func_setThreadSafeRefUnref( threadSafe );
        else{
            this->osg::Group::setThreadSafeRefUnref( threadSafe );
        }
    }
    
    void default_setThreadSafeRefUnref( bool threadSafe ) {
        osg::Group::setThreadSafeRefUnref( threadSafe );
    }

    virtual void setUserData( ::osg::Referenced * obj ) {
        if( bp::override func_setUserData = this->get_override( "setUserData" ) )
            func_setUserData( boost::python::ptr(obj) );
        else{
            this->osg::Object::setUserData( boost::python::ptr(obj) );
        }
    }
    
    void default_setUserData( ::osg::Referenced * obj ) {
        osg::Object::setUserData( boost::python::ptr(obj) );
    }

};

void register_Impostor_class(){

    bp::class_< Impostor_wrapper, bp::bases< ::osg::LOD >, osg::ref_ptr< Impostor_wrapper >, boost::noncopyable >( "Impostor", "\n Impostor - is a form of Level Of Detail group node which allows both switching\n between children depending on distance from eye point and image caching.\n\n The principle behind Imposters is that they cache an image of real geometry and then the image is drawn\n in subsequent frames instead of the real geometry. Its a bit like a\n Billboard *but* is updated at runtime and w.r.t view point. By drawing\n just the texture mapped quad you can cut down scene complexity and\n improve performance.\n\n For more details have a look at:\n\n    http://grail.cs.washington.edu/projects/hic\n\n The OSG doesnt implement exactly the same technique as above, but its\n should be a good starting place. The OSGs impostors are much less\n intrusive since you dont need to restructure your whole scene to use\n them.\n\n All you need to do to use Impostors is to set up the visible\n range values for each LOD child of the Impostor, as per osg::LOD,\n and set an Impostor threshold to tell the renderer at what distance\n the Impostors image caching should cut in.  The osg::CullVisitor\n automatically handles all the setting of pre-rendering stages to\n calculate the required ImpostorSprites (which encapsulates the image\n cache and quad), and updates them as the view point changes. If you\n use osg::SceneView/CullVisitor all the complexity of supporting\n Impostor will be nicely hidden away.\n\n TODO:\n Various improvements are planned for the Impostor-\n 1) Estimation of how many frames an ImpostorSprite will be reused, if\n it wont be used more often than a minimum threshold then do not create\n ImpostorSprite - use the real geometry.\n 2) Sharing of texture memory between ImpostorSprites.\n 3) Simple 3D geometry for ImpostorSprites rather than Billboarding.\n 4) Shrinking of the ImpostorSprite size to more closely fit the underlying\n geometry.\n", bp::no_init )    
        .def( bp::init< >("\n Impostor - is a form of Level Of Detail group node which allows both switching\n between children depending on distance from eye point and image caching.\n\n The principle behind Imposters is that they cache an image of real geometry and then the image is drawn\n in subsequent frames instead of the real geometry. Its a bit like a\n Billboard *but* is updated at runtime and w.r.t view point. By drawing\n just the texture mapped quad you can cut down scene complexity and\n improve performance.\n\n For more details have a look at:\n\n    http://grail.cs.washington.edu/projects/hic\n\n The OSG doesnt implement exactly the same technique as above, but its\n should be a good starting place. The OSGs impostors are much less\n intrusive since you dont need to restructure your whole scene to use\n them.\n\n All you need to do to use Impostors is to set up the visible\n range values for each LOD child of the Impostor, as per osg::LOD,\n and set an Impostor threshold to tell the renderer at what distance\n the Impostors image caching should cut in.  The osg::CullVisitor\n automatically handles all the setting of pre-rendering stages to\n calculate the required ImpostorSprites (which encapsulates the image\n cache and quad), and updates them as the view point changes. If you\n use osg::SceneView/CullVisitor all the complexity of supporting\n Impostor will be nicely hidden away.\n\n TODO:\n Various improvements are planned for the Impostor-\n 1) Estimation of how many frames an ImpostorSprite will be reused, if\n it wont be used more often than a minimum threshold then do not create\n ImpostorSprite - use the real geometry.\n 2) Sharing of texture memory between ImpostorSprites.\n 3) Simple 3D geometry for ImpostorSprites rather than Billboarding.\n 4) Shrinking of the ImpostorSprite size to more closely fit the underlying\n geometry.\n") )    
        .def( 
            "accept"
            , (void ( ::osgSim::Impostor::* )( ::osg::NodeVisitor & ))(&::osgSim::Impostor::accept)
            , (void ( Impostor_wrapper::* )( ::osg::NodeVisitor & ))(&Impostor_wrapper::default_accept)
            , ( bp::arg("nv") ) )    
        .def( 
            "addImpostorSprite"
            , (void ( ::osgSim::Impostor::* )( unsigned int,::osgSim::ImpostorSprite * ))( &::osgSim::Impostor::addImpostorSprite )
            , ( bp::arg("contextID"), bp::arg("is") )
            , " Add an ImpostorSprite to the Impostor." )    
        .def( 
            "className"
            , (char const * ( ::osgSim::Impostor::* )(  )const)(&::osgSim::Impostor::className)
            , (char const * ( Impostor_wrapper::* )(  )const)(&Impostor_wrapper::default_className) )    
        .def( 
            "clone"
            , (::osg::Object * ( ::osgSim::Impostor::* )( ::osg::CopyOp const & )const)(&::osgSim::Impostor::clone)
            , (::osg::Object * ( Impostor_wrapper::* )( ::osg::CopyOp const & )const)(&Impostor_wrapper::default_clone)
            , ( bp::arg("copyop") )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "cloneType"
            , (::osg::Object * ( ::osgSim::Impostor::* )(  )const)(&::osgSim::Impostor::cloneType)
            , (::osg::Object * ( Impostor_wrapper::* )(  )const)(&Impostor_wrapper::default_cloneType)
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "computeBound"
            , (::osg::BoundingSphere ( ::osgSim::Impostor::* )(  )const)(&::osgSim::Impostor::computeBound)
            , (::osg::BoundingSphere ( Impostor_wrapper::* )(  )const)(&Impostor_wrapper::default_computeBound) )    
        .def( 
            "findBestImpostorSprite"
            , (::osgSim::ImpostorSprite * ( ::osgSim::Impostor::* )( unsigned int,::osg::Vec3 const & )const)( &::osgSim::Impostor::findBestImpostorSprite )
            , ( bp::arg("contextID"), bp::arg("currLocalEyePoint") )
            , bp::return_internal_reference< >()
            , " Find the ImposterSprite which fits the current eye point best." )    
        .def( 
            "getImpostorSpriteList"
            , (::std::vector< osg::ref_ptr<osgSim::ImpostorSprite> > & ( ::osgSim::Impostor::* )( unsigned int ))( &::osgSim::Impostor::getImpostorSpriteList )
            , ( bp::arg("contexID") )
            , bp::return_internal_reference< >()
            , " Get the list of ImpostorSprites attached to this Impostor." )    
        .def( 
            "getImpostorSpriteList"
            , (::std::vector< osg::ref_ptr<osgSim::ImpostorSprite> > const & ( ::osgSim::Impostor::* )( unsigned int )const)( &::osgSim::Impostor::getImpostorSpriteList )
            , ( bp::arg("contexID") )
            , bp::return_internal_reference< >()
            , " Get a const list of ImpostorSprites attached to this const Impostor." )    
        .def( 
            "getImpostorThreshold"
            , (float ( ::osgSim::Impostor::* )(  )const)( &::osgSim::Impostor::getImpostorThreshold ) )    
        .def( 
            "isSameKindAs"
            , (bool ( ::osgSim::Impostor::* )( ::osg::Object const * )const)(&::osgSim::Impostor::isSameKindAs)
            , (bool ( Impostor_wrapper::* )( ::osg::Object const * )const)(&Impostor_wrapper::default_isSameKindAs)
            , ( bp::arg("obj") ) )    
        .def( 
            "libraryName"
            , (char const * ( ::osgSim::Impostor::* )(  )const)(&::osgSim::Impostor::libraryName)
            , (char const * ( Impostor_wrapper::* )(  )const)(&Impostor_wrapper::default_libraryName) )    
        .def( 
            "setImpostorThreshold"
            , (void ( ::osgSim::Impostor::* )( float ))( &::osgSim::Impostor::setImpostorThreshold )
            , ( bp::arg("distance") )
            , " Set the Impostor threshold distance.\n For eye points further than this threshold the Imposter is used if appropriate,\n otherwise the LOD children as chosen as per a standard LOD node." )    
        .def( 
            "setImpostorThresholdToBound"
            , (void ( ::osgSim::Impostor::* )( float ))( &::osgSim::Impostor::setImpostorThresholdToBound )
            , ( bp::arg("ratio")=1.0e+0f )
            , " Set the Impostor threshold distance relative to the nodes bounding\n spheres radius." )    
        .def( 
            "traverse"
            , (void ( ::osgSim::Impostor::* )( ::osg::NodeVisitor & ))(&::osgSim::Impostor::traverse)
            , (void ( Impostor_wrapper::* )( ::osg::NodeVisitor & ))(&Impostor_wrapper::default_traverse)
            , ( bp::arg("nv") ) );

}
