// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osgfx.h"
#include "wrap_referenced.h"
#include "effect.pypp.hpp"

namespace bp = boost::python;

struct Effect_wrapper : osgFX::Effect, bp::wrapper< osgFX::Effect > {

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osgFX::Effect::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osgFX::Effect::className( );
    }

    virtual char const * effectAuthor(  ) const {
        bp::override func_effectAuthor = this->get_override( "effectAuthor" );
        return func_effectAuthor(  );
    }

    virtual char const * effectDescription(  ) const {
        bp::override func_effectDescription = this->get_override( "effectDescription" );
        return func_effectDescription(  );
    }

    virtual char const * effectName(  ) const {
        bp::override func_effectName = this->get_override( "effectName" );
        return func_effectName(  );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osgFX::Effect::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osgFX::Effect::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osgFX::Effect::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osgFX::Effect::libraryName( );
    }

    virtual void setUpDemo(  ) {
        if( bp::override func_setUpDemo = this->get_override( "setUpDemo" ) )
            func_setUpDemo(  );
        else{
            this->osgFX::Effect::setUpDemo(  );
        }
    }
    
    void default_setUpDemo(  ) {
        osgFX::Effect::setUpDemo( );
    }

    virtual void traverse( ::osg::NodeVisitor & nv ) {
        if( bp::override func_traverse = this->get_override( "traverse" ) )
            func_traverse( boost::ref(nv) );
        else{
            this->osgFX::Effect::traverse( boost::ref(nv) );
        }
    }
    
    void default_traverse( ::osg::NodeVisitor & nv ) {
        osgFX::Effect::traverse( boost::ref(nv) );
    }

    virtual void accept( ::osg::NodeVisitor & nv ) {
        if( bp::override func_accept = this->get_override( "accept" ) )
            func_accept( boost::ref(nv) );
        else{
            this->osg::Group::accept( boost::ref(nv) );
        }
    }
    
    void default_accept( ::osg::NodeVisitor & nv ) {
        osg::Group::accept( boost::ref(nv) );
    }

    virtual bool addChild( ::osg::Node * child ) {
        if( bp::override func_addChild = this->get_override( "addChild" ) )
            return func_addChild( boost::python::ptr(child) );
        else{
            return this->osg::Group::addChild( boost::python::ptr(child) );
        }
    }
    
    bool default_addChild( ::osg::Node * child ) {
        return osg::Group::addChild( boost::python::ptr(child) );
    }

    virtual ::osg::Camera * asCamera(  ) {
        if( bp::override func_asCamera = this->get_override( "asCamera" ) )
            return func_asCamera(  );
        else{
            return this->osg::Node::asCamera(  );
        }
    }
    
    ::osg::Camera * default_asCamera(  ) {
        return osg::Node::asCamera( );
    }

    virtual ::osg::Camera const * asCamera(  ) const  {
        if( bp::override func_asCamera = this->get_override( "asCamera" ) )
            return func_asCamera(  );
        else{
            return this->osg::Node::asCamera(  );
        }
    }
    
    ::osg::Camera const * default_asCamera(  ) const  {
        return osg::Node::asCamera( );
    }

    virtual ::osg::Geode * asGeode(  ) {
        if( bp::override func_asGeode = this->get_override( "asGeode" ) )
            return func_asGeode(  );
        else{
            return this->osg::Node::asGeode(  );
        }
    }
    
    ::osg::Geode * default_asGeode(  ) {
        return osg::Node::asGeode( );
    }

    virtual ::osg::Geode const * asGeode(  ) const  {
        if( bp::override func_asGeode = this->get_override( "asGeode" ) )
            return func_asGeode(  );
        else{
            return this->osg::Node::asGeode(  );
        }
    }
    
    ::osg::Geode const * default_asGeode(  ) const  {
        return osg::Node::asGeode( );
    }

    virtual ::osg::Group * asGroup(  ) {
        if( bp::override func_asGroup = this->get_override( "asGroup" ) )
            return func_asGroup(  );
        else{
            return this->osg::Group::asGroup(  );
        }
    }
    
    ::osg::Group * default_asGroup(  ) {
        return osg::Group::asGroup( );
    }

    virtual ::osg::Group const * asGroup(  ) const  {
        if( bp::override func_asGroup = this->get_override( "asGroup" ) )
            return func_asGroup(  );
        else{
            return this->osg::Group::asGroup(  );
        }
    }
    
    ::osg::Group const * default_asGroup(  ) const  {
        return osg::Group::asGroup( );
    }

    virtual ::osg::Switch * asSwitch(  ) {
        if( bp::override func_asSwitch = this->get_override( "asSwitch" ) )
            return func_asSwitch(  );
        else{
            return this->osg::Node::asSwitch(  );
        }
    }
    
    ::osg::Switch * default_asSwitch(  ) {
        return osg::Node::asSwitch( );
    }

    virtual ::osg::Switch const * asSwitch(  ) const  {
        if( bp::override func_asSwitch = this->get_override( "asSwitch" ) )
            return func_asSwitch(  );
        else{
            return this->osg::Node::asSwitch(  );
        }
    }
    
    ::osg::Switch const * default_asSwitch(  ) const  {
        return osg::Node::asSwitch( );
    }

    virtual ::osg::Transform * asTransform(  ) {
        if( bp::override func_asTransform = this->get_override( "asTransform" ) )
            return func_asTransform(  );
        else{
            return this->osg::Node::asTransform(  );
        }
    }
    
    ::osg::Transform * default_asTransform(  ) {
        return osg::Node::asTransform( );
    }

    virtual ::osg::Transform const * asTransform(  ) const  {
        if( bp::override func_asTransform = this->get_override( "asTransform" ) )
            return func_asTransform(  );
        else{
            return this->osg::Node::asTransform(  );
        }
    }
    
    ::osg::Transform const * default_asTransform(  ) const  {
        return osg::Node::asTransform( );
    }

    virtual void ascend( ::osg::NodeVisitor & nv ) {
        if( bp::override func_ascend = this->get_override( "ascend" ) )
            func_ascend( boost::ref(nv) );
        else{
            this->osg::Node::ascend( boost::ref(nv) );
        }
    }
    
    void default_ascend( ::osg::NodeVisitor & nv ) {
        osg::Node::ascend( boost::ref(nv) );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone( boost::ref(copyop) );
        else{
            return this->osg::Group::clone( boost::ref(copyop) );
        }
    }
    
    ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
        return osg::Group::clone( boost::ref(copyop) );
    }

    virtual ::osg::Object * cloneType(  ) const  {
        if( bp::override func_cloneType = this->get_override( "cloneType" ) )
            return func_cloneType(  );
        else{
            return this->osg::Group::cloneType(  );
        }
    }
    
    ::osg::Object * default_cloneType(  ) const  {
        return osg::Group::cloneType( );
    }

    virtual ::osg::BoundingSphere computeBound(  ) const  {
        if( bp::override func_computeBound = this->get_override( "computeBound" ) )
            return func_computeBound(  );
        else{
            return this->osg::Group::computeBound(  );
        }
    }
    
    ::osg::BoundingSphere default_computeBound(  ) const  {
        return osg::Group::computeBound( );
    }

    virtual void computeDataVariance(  ) {
        if( bp::override func_computeDataVariance = this->get_override( "computeDataVariance" ) )
            func_computeDataVariance(  );
        else{
            this->osg::Object::computeDataVariance(  );
        }
    }
    
    void default_computeDataVariance(  ) {
        osg::Object::computeDataVariance( );
    }

    virtual ::osg::Referenced * getUserData(  ) {
        if( bp::override func_getUserData = this->get_override( "getUserData" ) )
            return func_getUserData(  );
        else{
            return this->osg::Object::getUserData(  );
        }
    }
    
    ::osg::Referenced * default_getUserData(  ) {
        return osg::Object::getUserData( );
    }

    virtual ::osg::Referenced const * getUserData(  ) const  {
        if( bp::override func_getUserData = this->get_override( "getUserData" ) )
            return func_getUserData(  );
        else{
            return this->osg::Object::getUserData(  );
        }
    }
    
    ::osg::Referenced const * default_getUserData(  ) const  {
        return osg::Object::getUserData( );
    }

    virtual bool insertChild( unsigned int index, ::osg::Node * child ) {
        if( bp::override func_insertChild = this->get_override( "insertChild" ) )
            return func_insertChild( index, boost::python::ptr(child) );
        else{
            return this->osg::Group::insertChild( index, boost::python::ptr(child) );
        }
    }
    
    bool default_insertChild( unsigned int index, ::osg::Node * child ) {
        return osg::Group::insertChild( index, boost::python::ptr(child) );
    }

    virtual bool removeChildren( unsigned int pos, unsigned int numChildrenToRemove ) {
        if( bp::override func_removeChildren = this->get_override( "removeChildren" ) )
            return func_removeChildren( pos, numChildrenToRemove );
        else{
            return this->osg::Group::removeChildren( pos, numChildrenToRemove );
        }
    }
    
    bool default_removeChildren( unsigned int pos, unsigned int numChildrenToRemove ) {
        return osg::Group::removeChildren( pos, numChildrenToRemove );
    }

    virtual bool replaceChild( ::osg::Node * origChild, ::osg::Node * newChild ) {
        if( bp::override func_replaceChild = this->get_override( "replaceChild" ) )
            return func_replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
        else{
            return this->osg::Group::replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
        }
    }
    
    bool default_replaceChild( ::osg::Node * origChild, ::osg::Node * newChild ) {
        return osg::Group::replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
    }

    virtual void resizeGLObjectBuffers( unsigned int maxSize ) {
        if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
            func_resizeGLObjectBuffers( maxSize );
        else{
            this->osg::Group::resizeGLObjectBuffers( maxSize );
        }
    }
    
    void default_resizeGLObjectBuffers( unsigned int maxSize ) {
        osg::Group::resizeGLObjectBuffers( maxSize );
    }

    virtual bool setChild( unsigned int i, ::osg::Node * node ) {
        if( bp::override func_setChild = this->get_override( "setChild" ) )
            return func_setChild( i, boost::python::ptr(node) );
        else{
            return this->osg::Group::setChild( i, boost::python::ptr(node) );
        }
    }
    
    bool default_setChild( unsigned int i, ::osg::Node * node ) {
        return osg::Group::setChild( i, boost::python::ptr(node) );
    }

    virtual void setName( ::std::string const & name ) {
        if( bp::override func_setName = this->get_override( "setName" ) )
            func_setName( name );
        else{
            this->osg::Object::setName( name );
        }
    }
    
    void default_setName( ::std::string const & name ) {
        osg::Object::setName( name );
    }

    virtual void setThreadSafeRefUnref( bool threadSafe ) {
        if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
            func_setThreadSafeRefUnref( threadSafe );
        else{
            this->osg::Group::setThreadSafeRefUnref( threadSafe );
        }
    }
    
    void default_setThreadSafeRefUnref( bool threadSafe ) {
        osg::Group::setThreadSafeRefUnref( threadSafe );
    }

    virtual void setUserData( ::osg::Referenced * obj ) {
        if( bp::override func_setUserData = this->get_override( "setUserData" ) )
            func_setUserData( boost::python::ptr(obj) );
        else{
            this->osg::Object::setUserData( boost::python::ptr(obj) );
        }
    }
    
    void default_setUserData( ::osg::Referenced * obj ) {
        osg::Object::setUserData( boost::python::ptr(obj) );
    }

};

void register_Effect_class(){

    { //::osgFX::Effect
        typedef bp::class_< Effect_wrapper, bp::bases< ::osg::Group >, osg::ref_ptr< Effect_wrapper >, boost::noncopyable > Effect_exposer_t;
        Effect_exposer_t Effect_exposer = Effect_exposer_t( "Effect", "\n     The base class for special effects. An effect is basically a collection of\n     state attributes and an interface for configuring them in a predefined\n     fashion. The Effect class does more however, as it handles multipass\n     rendering transparently and it allows more than one technique to be\n     defined. Each technique tries to implement the effect in a different way,\n     often using different OpenGL extensions. The active technique can be\n     selected either manually, with selectTechnique(), or automatically, in which\n     case the first technique that is supported by all active rendering contexts\n     is chosen.\n     If you are an Effect user, then simply use it as a node group. Create an\n     instance of your desired effect, add it to your scene graph and call its\n     addChild() method to add a child node as you would do with a Group.\n     If you are an Effect developer, you will have to implement the method\n     define_techniques() to define the different techniques that can be used\n     for obtaining the desired effect. In define_techniques() you will usually\n     create one or more instances of custom classes derived from Technique and\n     you will add them to the effect with addTechnique(). The order is important:\n     techniques added first will have higher priority and will be used first as\n     soon as all rendering contexts support it.\n", bp::no_init );
        bp::scope Effect_scope( Effect_exposer );
        bp::enum_< osgFX::Effect::TechniqueSelection>("TechniqueSelection")
            .value("AUTO_DETECT", osgFX::Effect::AUTO_DETECT)
            .export_values()
            ;
        { //::osgFX::Effect::className
        
            typedef char const * ( ::osgFX::Effect::*className_function_type)(  ) const;
            typedef char const * ( Effect_wrapper::*default_className_function_type)(  ) const;
            
            Effect_exposer.def( 
                "className"
                , className_function_type(&::osgFX::Effect::className)
                , default_className_function_type(&Effect_wrapper::default_className) );
        
        }
        { //::osgFX::Effect::effectAuthor
        
            typedef char const * ( ::osgFX::Effect::*effectAuthor_function_type)(  ) const;
            
            Effect_exposer.def( 
                "effectAuthor"
                , bp::pure_virtual( effectAuthor_function_type(&::osgFX::Effect::effectAuthor) )
                , "\n get the effect authors name\n" );
        
        }
        { //::osgFX::Effect::effectDescription
        
            typedef char const * ( ::osgFX::Effect::*effectDescription_function_type)(  ) const;
            
            Effect_exposer.def( 
                "effectDescription"
                , bp::pure_virtual( effectDescription_function_type(&::osgFX::Effect::effectDescription) )
                , "\n get a brief description of this Effect\n" );
        
        }
        { //::osgFX::Effect::effectName
        
            typedef char const * ( ::osgFX::Effect::*effectName_function_type)(  ) const;
            
            Effect_exposer.def( 
                "effectName"
                , bp::pure_virtual( effectName_function_type(&::osgFX::Effect::effectName) )
                , "\n get the name of this Effect\n" );
        
        }
        { //::osgFX::Effect::getEnabled
        
            typedef bool ( ::osgFX::Effect::*getEnabled_function_type)(  ) const;
            
            Effect_exposer.def( 
                "getEnabled"
                , getEnabled_function_type( &::osgFX::Effect::getEnabled ) );
        
        }
        { //::osgFX::Effect::getNumTechniques
        
            typedef int ( ::osgFX::Effect::*getNumTechniques_function_type)(  ) const;
            
            Effect_exposer.def( 
                "getNumTechniques"
                , getNumTechniques_function_type( &::osgFX::Effect::getNumTechniques ) );
        
        }
        { //::osgFX::Effect::getSelectedTechnique
        
            typedef int ( ::osgFX::Effect::*getSelectedTechnique_function_type)(  ) const;
            
            Effect_exposer.def( 
                "getSelectedTechnique"
                , getSelectedTechnique_function_type( &::osgFX::Effect::getSelectedTechnique ) );
        
        }
        { //::osgFX::Effect::getTechnique
        
            typedef ::osgFX::Technique * ( ::osgFX::Effect::*getTechnique_function_type)( int ) ;
            
            Effect_exposer.def( 
                "getTechnique"
                , getTechnique_function_type( &::osgFX::Effect::getTechnique )
                , ( bp::arg("i") )
                , bp::return_internal_reference< >() );
        
        }
        { //::osgFX::Effect::getTechnique
        
            typedef ::osgFX::Technique const * ( ::osgFX::Effect::*getTechnique_function_type)( int ) const;
            
            Effect_exposer.def( 
                "getTechnique"
                , getTechnique_function_type( &::osgFX::Effect::getTechnique )
                , ( bp::arg("i") )
                , bp::return_internal_reference< >() );
        
        }
        { //::osgFX::Effect::inherited_traverse
        
            typedef void ( ::osgFX::Effect::*inherited_traverse_function_type)( ::osg::NodeVisitor & ) ;
            
            Effect_exposer.def( 
                "inherited_traverse"
                , inherited_traverse_function_type( &::osgFX::Effect::inherited_traverse )
                , ( bp::arg("nv") ) );
        
        }
        { //::osgFX::Effect::isSameKindAs
        
            typedef bool ( ::osgFX::Effect::*isSameKindAs_function_type)( ::osg::Object const * ) const;
            typedef bool ( Effect_wrapper::*default_isSameKindAs_function_type)( ::osg::Object const * ) const;
            
            Effect_exposer.def( 
                "isSameKindAs"
                , isSameKindAs_function_type(&::osgFX::Effect::isSameKindAs)
                , default_isSameKindAs_function_type(&Effect_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) );
        
        }
        { //::osgFX::Effect::libraryName
        
            typedef char const * ( ::osgFX::Effect::*libraryName_function_type)(  ) const;
            typedef char const * ( Effect_wrapper::*default_libraryName_function_type)(  ) const;
            
            Effect_exposer.def( 
                "libraryName"
                , libraryName_function_type(&::osgFX::Effect::libraryName)
                , default_libraryName_function_type(&Effect_wrapper::default_libraryName) );
        
        }
        { //::osgFX::Effect::selectTechnique
        
            typedef void ( ::osgFX::Effect::*selectTechnique_function_type)( int ) ;
            
            Effect_exposer.def( 
                "selectTechnique"
                , selectTechnique_function_type( &::osgFX::Effect::selectTechnique )
                , ( bp::arg("i")=int(::osgFX::Effect::AUTO_DETECT) ) );
        
        }
        { //::osgFX::Effect::setEnabled
        
            typedef void ( ::osgFX::Effect::*setEnabled_function_type)( bool ) ;
            
            Effect_exposer.def( 
                "setEnabled"
                , setEnabled_function_type( &::osgFX::Effect::setEnabled )
                , ( bp::arg("v") ) );
        
        }
        { //::osgFX::Effect::setUpDemo
        
            typedef void ( ::osgFX::Effect::*setUpDemo_function_type)(  ) ;
            typedef void ( Effect_wrapper::*default_setUpDemo_function_type)(  ) ;
            
            Effect_exposer.def( 
                "setUpDemo"
                , setUpDemo_function_type(&::osgFX::Effect::setUpDemo)
                , default_setUpDemo_function_type(&Effect_wrapper::default_setUpDemo) );
        
        }
        { //::osgFX::Effect::traverse
        
            typedef void ( ::osgFX::Effect::*traverse_function_type)( ::osg::NodeVisitor & ) ;
            typedef void ( Effect_wrapper::*default_traverse_function_type)( ::osg::NodeVisitor & ) ;
            
            Effect_exposer.def( 
                "traverse"
                , traverse_function_type(&::osgFX::Effect::traverse)
                , default_traverse_function_type(&Effect_wrapper::default_traverse)
                , ( bp::arg("nv") ) );
        
        }
    }

}
